// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_listener.proto

#ifndef PROTOBUF_INCLUDED_client_5flistener_2eproto
#define PROTOBUF_INCLUDED_client_5flistener_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_client_5flistener_2eproto 

namespace protobuf_client_5flistener_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[35];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_client_5flistener_2eproto
class ClientQueryRequest;
class ClientQueryRequestDefaultTypeInternal;
extern ClientQueryRequestDefaultTypeInternal _ClientQueryRequest_default_instance_;
class ClientWrappedMessage;
class ClientWrappedMessageDefaultTypeInternal;
extern ClientWrappedMessageDefaultTypeInternal _ClientWrappedMessage_default_instance_;
class GameInfo;
class GameInfoDefaultTypeInternal;
extern GameInfoDefaultTypeInternal _GameInfo_default_instance_;
class GameState;
class GameStateDefaultTypeInternal;
extern GameStateDefaultTypeInternal _GameState_default_instance_;
class InvitationToPlayGame;
class InvitationToPlayGameDefaultTypeInternal;
extern InvitationToPlayGameDefaultTypeInternal _InvitationToPlayGame_default_instance_;
class InvitationToViewGame;
class InvitationToViewGameDefaultTypeInternal;
extern InvitationToViewGameDefaultTypeInternal _InvitationToViewGame_default_instance_;
class KeyboardKey;
class KeyboardKeyDefaultTypeInternal;
extern KeyboardKeyDefaultTypeInternal _KeyboardKey_default_instance_;
class ListenerToClientGamesStates;
class ListenerToClientGamesStatesDefaultTypeInternal;
extern ListenerToClientGamesStatesDefaultTypeInternal _ListenerToClientGamesStates_default_instance_;
class ListenerToClientWrappedMessage;
class ListenerToClientWrappedMessageDefaultTypeInternal;
extern ListenerToClientWrappedMessageDefaultTypeInternal _ListenerToClientWrappedMessage_default_instance_;
class ListenerToClientsWebRTCGamesStates;
class ListenerToClientsWebRTCGamesStatesDefaultTypeInternal;
extern ListenerToClientsWebRTCGamesStatesDefaultTypeInternal _ListenerToClientsWebRTCGamesStates_default_instance_;
class ListenerToClientsWebRTCRefuse;
class ListenerToClientsWebRTCRefuseDefaultTypeInternal;
extern ListenerToClientsWebRTCRefuseDefaultTypeInternal _ListenerToClientsWebRTCRefuse_default_instance_;
class OneChargeInfo;
class OneChargeInfoDefaultTypeInternal;
extern OneChargeInfoDefaultTypeInternal _OneChargeInfo_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PlayGameRequest;
class PlayGameRequestDefaultTypeInternal;
extern PlayGameRequestDefaultTypeInternal _PlayGameRequest_default_instance_;
class RTCAdmin2ClientOffer;
class RTCAdmin2ClientOfferDefaultTypeInternal;
extern RTCAdmin2ClientOfferDefaultTypeInternal _RTCAdmin2ClientOffer_default_instance_;
class RTCClient2AdminAnswer;
class RTCClient2AdminAnswerDefaultTypeInternal;
extern RTCClient2AdminAnswerDefaultTypeInternal _RTCClient2AdminAnswer_default_instance_;
class RTCGameAdminRequest;
class RTCGameAdminRequestDefaultTypeInternal;
extern RTCGameAdminRequestDefaultTypeInternal _RTCGameAdminRequest_default_instance_;
class RTCGameClientRequest;
class RTCGameClientRequestDefaultTypeInternal;
extern RTCGameClientRequestDefaultTypeInternal _RTCGameClientRequest_default_instance_;
class ResponceOnGameInvitation;
class ResponceOnGameInvitationDefaultTypeInternal;
extern ResponceOnGameInvitationDefaultTypeInternal _ResponceOnGameInvitation_default_instance_;
class ResponceOnGameView;
class ResponceOnGameViewDefaultTypeInternal;
extern ResponceOnGameViewDefaultTypeInternal _ResponceOnGameView_default_instance_;
class RoomInfo;
class RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class RoomToClient;
class RoomToClientDefaultTypeInternal;
extern RoomToClientDefaultTypeInternal _RoomToClient_default_instance_;
class RoomWrappedMessage;
class RoomWrappedMessageDefaultTypeInternal;
extern RoomWrappedMessageDefaultTypeInternal _RoomWrappedMessage_default_instance_;
class RoomWrappedToClientMessage;
class RoomWrappedToClientMessageDefaultTypeInternal;
extern RoomWrappedToClientMessageDefaultTypeInternal _RoomWrappedToClientMessage_default_instance_;
class SceneGeometry;
class SceneGeometryDefaultTypeInternal;
extern SceneGeometryDefaultTypeInternal _SceneGeometry_default_instance_;
class ServerWrappedMessage;
class ServerWrappedMessageDefaultTypeInternal;
extern ServerWrappedMessageDefaultTypeInternal _ServerWrappedMessage_default_instance_;
class SetLightVelocity;
class SetLightVelocityDefaultTypeInternal;
extern SetLightVelocityDefaultTypeInternal _SetLightVelocity_default_instance_;
class SetMagneticCalculated;
class SetMagneticCalculatedDefaultTypeInternal;
extern SetMagneticCalculatedDefaultTypeInternal _SetMagneticCalculated_default_instance_;
class SetQulon;
class SetQulonDefaultTypeInternal;
extern SetQulonDefaultTypeInternal _SetQulon_default_instance_;
class ShowStruct;
class ShowStructDefaultTypeInternal;
extern ShowStructDefaultTypeInternal _ShowStruct_default_instance_;
class StartGame;
class StartGameDefaultTypeInternal;
extern StartGameDefaultTypeInternal _StartGame_default_instance_;
class ViewGameRequest;
class ViewGameRequestDefaultTypeInternal;
extern ViewGameRequestDefaultTypeInternal _ViewGameRequest_default_instance_;
class WebRTCAdminToClientMessage;
class WebRTCAdminToClientMessageDefaultTypeInternal;
extern WebRTCAdminToClientMessageDefaultTypeInternal _WebRTCAdminToClientMessage_default_instance_;
class WebRTCGameInfo;
class WebRTCGameInfoDefaultTypeInternal;
extern WebRTCGameInfoDefaultTypeInternal _WebRTCGameInfo_default_instance_;
class rtcGameState;
class rtcGameStateDefaultTypeInternal;
extern rtcGameStateDefaultTypeInternal _rtcGameState_default_instance_;
namespace google {
namespace protobuf {
template<> ::ClientQueryRequest* Arena::CreateMaybeMessage<::ClientQueryRequest>(Arena*);
template<> ::ClientWrappedMessage* Arena::CreateMaybeMessage<::ClientWrappedMessage>(Arena*);
template<> ::GameInfo* Arena::CreateMaybeMessage<::GameInfo>(Arena*);
template<> ::GameState* Arena::CreateMaybeMessage<::GameState>(Arena*);
template<> ::InvitationToPlayGame* Arena::CreateMaybeMessage<::InvitationToPlayGame>(Arena*);
template<> ::InvitationToViewGame* Arena::CreateMaybeMessage<::InvitationToViewGame>(Arena*);
template<> ::KeyboardKey* Arena::CreateMaybeMessage<::KeyboardKey>(Arena*);
template<> ::ListenerToClientGamesStates* Arena::CreateMaybeMessage<::ListenerToClientGamesStates>(Arena*);
template<> ::ListenerToClientWrappedMessage* Arena::CreateMaybeMessage<::ListenerToClientWrappedMessage>(Arena*);
template<> ::ListenerToClientsWebRTCGamesStates* Arena::CreateMaybeMessage<::ListenerToClientsWebRTCGamesStates>(Arena*);
template<> ::ListenerToClientsWebRTCRefuse* Arena::CreateMaybeMessage<::ListenerToClientsWebRTCRefuse>(Arena*);
template<> ::OneChargeInfo* Arena::CreateMaybeMessage<::OneChargeInfo>(Arena*);
template<> ::Ping* Arena::CreateMaybeMessage<::Ping>(Arena*);
template<> ::PlayGameRequest* Arena::CreateMaybeMessage<::PlayGameRequest>(Arena*);
template<> ::RTCAdmin2ClientOffer* Arena::CreateMaybeMessage<::RTCAdmin2ClientOffer>(Arena*);
template<> ::RTCClient2AdminAnswer* Arena::CreateMaybeMessage<::RTCClient2AdminAnswer>(Arena*);
template<> ::RTCGameAdminRequest* Arena::CreateMaybeMessage<::RTCGameAdminRequest>(Arena*);
template<> ::RTCGameClientRequest* Arena::CreateMaybeMessage<::RTCGameClientRequest>(Arena*);
template<> ::ResponceOnGameInvitation* Arena::CreateMaybeMessage<::ResponceOnGameInvitation>(Arena*);
template<> ::ResponceOnGameView* Arena::CreateMaybeMessage<::ResponceOnGameView>(Arena*);
template<> ::RoomInfo* Arena::CreateMaybeMessage<::RoomInfo>(Arena*);
template<> ::RoomToClient* Arena::CreateMaybeMessage<::RoomToClient>(Arena*);
template<> ::RoomWrappedMessage* Arena::CreateMaybeMessage<::RoomWrappedMessage>(Arena*);
template<> ::RoomWrappedToClientMessage* Arena::CreateMaybeMessage<::RoomWrappedToClientMessage>(Arena*);
template<> ::SceneGeometry* Arena::CreateMaybeMessage<::SceneGeometry>(Arena*);
template<> ::ServerWrappedMessage* Arena::CreateMaybeMessage<::ServerWrappedMessage>(Arena*);
template<> ::SetLightVelocity* Arena::CreateMaybeMessage<::SetLightVelocity>(Arena*);
template<> ::SetMagneticCalculated* Arena::CreateMaybeMessage<::SetMagneticCalculated>(Arena*);
template<> ::SetQulon* Arena::CreateMaybeMessage<::SetQulon>(Arena*);
template<> ::ShowStruct* Arena::CreateMaybeMessage<::ShowStruct>(Arena*);
template<> ::StartGame* Arena::CreateMaybeMessage<::StartGame>(Arena*);
template<> ::ViewGameRequest* Arena::CreateMaybeMessage<::ViewGameRequest>(Arena*);
template<> ::WebRTCAdminToClientMessage* Arena::CreateMaybeMessage<::WebRTCAdminToClientMessage>(Arena*);
template<> ::WebRTCGameInfo* Arena::CreateMaybeMessage<::WebRTCGameInfo>(Arena*);
template<> ::rtcGameState* Arena::CreateMaybeMessage<::rtcGameState>(Arena*);
}  // namespace protobuf
}  // namespace google

enum RoomInfo_GameStatusEnum {
  RoomInfo_GameStatusEnum_gseNone = 0,
  RoomInfo_GameStatusEnum_gseWaiting = 1,
  RoomInfo_GameStatusEnum_gsePlaying = 2,
  RoomInfo_GameStatusEnum_RoomInfo_GameStatusEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoomInfo_GameStatusEnum_RoomInfo_GameStatusEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoomInfo_GameStatusEnum_IsValid(int value);
const RoomInfo_GameStatusEnum RoomInfo_GameStatusEnum_GameStatusEnum_MIN = RoomInfo_GameStatusEnum_gseNone;
const RoomInfo_GameStatusEnum RoomInfo_GameStatusEnum_GameStatusEnum_MAX = RoomInfo_GameStatusEnum_gsePlaying;
const int RoomInfo_GameStatusEnum_GameStatusEnum_ARRAYSIZE = RoomInfo_GameStatusEnum_GameStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomInfo_GameStatusEnum_descriptor();
inline const ::std::string& RoomInfo_GameStatusEnum_Name(RoomInfo_GameStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomInfo_GameStatusEnum_descriptor(), value);
}
inline bool RoomInfo_GameStatusEnum_Parse(
    const ::std::string& name, RoomInfo_GameStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomInfo_GameStatusEnum>(
    RoomInfo_GameStatusEnum_descriptor(), name, value);
}
enum OneChargeInfo_Charge2DType {
  OneChargeInfo_Charge2DType_ctStatic = 0,
  OneChargeInfo_Charge2DType_ctDynamic = 1,
  OneChargeInfo_Charge2DType_OneChargeInfo_Charge2DType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OneChargeInfo_Charge2DType_OneChargeInfo_Charge2DType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OneChargeInfo_Charge2DType_IsValid(int value);
const OneChargeInfo_Charge2DType OneChargeInfo_Charge2DType_Charge2DType_MIN = OneChargeInfo_Charge2DType_ctStatic;
const OneChargeInfo_Charge2DType OneChargeInfo_Charge2DType_Charge2DType_MAX = OneChargeInfo_Charge2DType_ctDynamic;
const int OneChargeInfo_Charge2DType_Charge2DType_ARRAYSIZE = OneChargeInfo_Charge2DType_Charge2DType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OneChargeInfo_Charge2DType_descriptor();
inline const ::std::string& OneChargeInfo_Charge2DType_Name(OneChargeInfo_Charge2DType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OneChargeInfo_Charge2DType_descriptor(), value);
}
inline bool OneChargeInfo_Charge2DType_Parse(
    const ::std::string& name, OneChargeInfo_Charge2DType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OneChargeInfo_Charge2DType>(
    OneChargeInfo_Charge2DType_descriptor(), name, value);
}
enum ShowPaletteType {
  sptDiscrete = 0,
  sptContinuous = 1,
  ShowPaletteType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ShowPaletteType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ShowPaletteType_IsValid(int value);
const ShowPaletteType ShowPaletteType_MIN = sptDiscrete;
const ShowPaletteType ShowPaletteType_MAX = sptContinuous;
const int ShowPaletteType_ARRAYSIZE = ShowPaletteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShowPaletteType_descriptor();
inline const ::std::string& ShowPaletteType_Name(ShowPaletteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShowPaletteType_descriptor(), value);
}
inline bool ShowPaletteType_Parse(
    const ::std::string& name, ShowPaletteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShowPaletteType>(
    ShowPaletteType_descriptor(), name, value);
}
enum WebRTCPlayerStatus {
  rtcPlayerNone = 0,
  rtcPlayerAdmin = 1,
  rtcPlayerClient = 2,
  WebRTCPlayerStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WebRTCPlayerStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WebRTCPlayerStatus_IsValid(int value);
const WebRTCPlayerStatus WebRTCPlayerStatus_MIN = rtcPlayerNone;
const WebRTCPlayerStatus WebRTCPlayerStatus_MAX = rtcPlayerClient;
const int WebRTCPlayerStatus_ARRAYSIZE = WebRTCPlayerStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* WebRTCPlayerStatus_descriptor();
inline const ::std::string& WebRTCPlayerStatus_Name(WebRTCPlayerStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    WebRTCPlayerStatus_descriptor(), value);
}
inline bool WebRTCPlayerStatus_Parse(
    const ::std::string& name, WebRTCPlayerStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WebRTCPlayerStatus>(
    WebRTCPlayerStatus_descriptor(), name, value);
}
enum WebRTCGameRefuseReasons {
  rtcRefuseNoGameWithId = 0,
  rtcRefuseRoomIsFull = 1,
  WebRTCGameRefuseReasons_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WebRTCGameRefuseReasons_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WebRTCGameRefuseReasons_IsValid(int value);
const WebRTCGameRefuseReasons WebRTCGameRefuseReasons_MIN = rtcRefuseNoGameWithId;
const WebRTCGameRefuseReasons WebRTCGameRefuseReasons_MAX = rtcRefuseRoomIsFull;
const int WebRTCGameRefuseReasons_ARRAYSIZE = WebRTCGameRefuseReasons_MAX + 1;

const ::google::protobuf::EnumDescriptor* WebRTCGameRefuseReasons_descriptor();
inline const ::std::string& WebRTCGameRefuseReasons_Name(WebRTCGameRefuseReasons value) {
  return ::google::protobuf::internal::NameOfEnum(
    WebRTCGameRefuseReasons_descriptor(), value);
}
inline bool WebRTCGameRefuseReasons_Parse(
    const ::std::string& name, WebRTCGameRefuseReasons* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WebRTCGameRefuseReasons>(
    WebRTCGameRefuseReasons_descriptor(), name, value);
}
// ===================================================================

class RoomInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomInfo) */ {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RoomInfo* other);
  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomInfo* New() const final {
    return CreateMaybeMessage<RoomInfo>(NULL);
  }

  RoomInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoomInfo_GameStatusEnum GameStatusEnum;
  static const GameStatusEnum gseNone =
    RoomInfo_GameStatusEnum_gseNone;
  static const GameStatusEnum gseWaiting =
    RoomInfo_GameStatusEnum_gseWaiting;
  static const GameStatusEnum gsePlaying =
    RoomInfo_GameStatusEnum_gsePlaying;
  static inline bool GameStatusEnum_IsValid(int value) {
    return RoomInfo_GameStatusEnum_IsValid(value);
  }
  static const GameStatusEnum GameStatusEnum_MIN =
    RoomInfo_GameStatusEnum_GameStatusEnum_MIN;
  static const GameStatusEnum GameStatusEnum_MAX =
    RoomInfo_GameStatusEnum_GameStatusEnum_MAX;
  static const int GameStatusEnum_ARRAYSIZE =
    RoomInfo_GameStatusEnum_GameStatusEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GameStatusEnum_descriptor() {
    return RoomInfo_GameStatusEnum_descriptor();
  }
  static inline const ::std::string& GameStatusEnum_Name(GameStatusEnum value) {
    return RoomInfo_GameStatusEnum_Name(value);
  }
  static inline bool GameStatusEnum_Parse(const ::std::string& name,
      GameStatusEnum* value) {
    return RoomInfo_GameStatusEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string roomName = 1;
  void clear_roomname();
  static const int kRoomNameFieldNumber = 1;
  const ::std::string& roomname() const;
  void set_roomname(const ::std::string& value);
  #if LANG_CXX11
  void set_roomname(::std::string&& value);
  #endif
  void set_roomname(const char* value);
  void set_roomname(const char* value, size_t size);
  ::std::string* mutable_roomname();
  ::std::string* release_roomname();
  void set_allocated_roomname(::std::string* roomname);

  // .RoomInfo.GameStatusEnum gameStatus = 2;
  void clear_gamestatus();
  static const int kGameStatusFieldNumber = 2;
  ::RoomInfo_GameStatusEnum gamestatus() const;
  void set_gamestatus(::RoomInfo_GameStatusEnum value);

  // int32 roomSize = 3;
  void clear_roomsize();
  static const int kRoomSizeFieldNumber = 3;
  ::google::protobuf::int32 roomsize() const;
  void set_roomsize(::google::protobuf::int32 value);

  // int32 waitingSize = 4;
  void clear_waitingsize();
  static const int kWaitingSizeFieldNumber = 4;
  ::google::protobuf::int32 waitingsize() const;
  void set_waitingsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RoomInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr roomname_;
  int gamestatus_;
  ::google::protobuf::int32 roomsize_;
  ::google::protobuf::int32 waitingsize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponceOnGameInvitation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ResponceOnGameInvitation) */ {
 public:
  ResponceOnGameInvitation();
  virtual ~ResponceOnGameInvitation();

  ResponceOnGameInvitation(const ResponceOnGameInvitation& from);

  inline ResponceOnGameInvitation& operator=(const ResponceOnGameInvitation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponceOnGameInvitation(ResponceOnGameInvitation&& from) noexcept
    : ResponceOnGameInvitation() {
    *this = ::std::move(from);
  }

  inline ResponceOnGameInvitation& operator=(ResponceOnGameInvitation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponceOnGameInvitation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponceOnGameInvitation* internal_default_instance() {
    return reinterpret_cast<const ResponceOnGameInvitation*>(
               &_ResponceOnGameInvitation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ResponceOnGameInvitation* other);
  friend void swap(ResponceOnGameInvitation& a, ResponceOnGameInvitation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponceOnGameInvitation* New() const final {
    return CreateMaybeMessage<ResponceOnGameInvitation>(NULL);
  }

  ResponceOnGameInvitation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponceOnGameInvitation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponceOnGameInvitation& from);
  void MergeFrom(const ResponceOnGameInvitation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponceOnGameInvitation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientIp = 3;
  void clear_clientip();
  static const int kClientIpFieldNumber = 3;
  const ::std::string& clientip() const;
  void set_clientip(const ::std::string& value);
  #if LANG_CXX11
  void set_clientip(::std::string&& value);
  #endif
  void set_clientip(const char* value);
  void set_clientip(const char* value, size_t size);
  ::std::string* mutable_clientip();
  ::std::string* release_clientip();
  void set_allocated_clientip(::std::string* clientip);

  // bool responce = 1;
  void clear_responce();
  static const int kResponceFieldNumber = 1;
  bool responce() const;
  void set_responce(bool value);

  // int32 ticket = 2;
  void clear_ticket();
  static const int kTicketFieldNumber = 2;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // int32 clientPort = 4;
  void clear_clientport();
  static const int kClientPortFieldNumber = 4;
  ::google::protobuf::int32 clientport() const;
  void set_clientport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ResponceOnGameInvitation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientip_;
  bool responce_;
  ::google::protobuf::int32 ticket_;
  ::google::protobuf::int32 clientport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponceOnGameView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ResponceOnGameView) */ {
 public:
  ResponceOnGameView();
  virtual ~ResponceOnGameView();

  ResponceOnGameView(const ResponceOnGameView& from);

  inline ResponceOnGameView& operator=(const ResponceOnGameView& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponceOnGameView(ResponceOnGameView&& from) noexcept
    : ResponceOnGameView() {
    *this = ::std::move(from);
  }

  inline ResponceOnGameView& operator=(ResponceOnGameView&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponceOnGameView& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponceOnGameView* internal_default_instance() {
    return reinterpret_cast<const ResponceOnGameView*>(
               &_ResponceOnGameView_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ResponceOnGameView* other);
  friend void swap(ResponceOnGameView& a, ResponceOnGameView& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponceOnGameView* New() const final {
    return CreateMaybeMessage<ResponceOnGameView>(NULL);
  }

  ResponceOnGameView* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponceOnGameView>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponceOnGameView& from);
  void MergeFrom(const ResponceOnGameView& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponceOnGameView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientIp = 3;
  void clear_clientip();
  static const int kClientIpFieldNumber = 3;
  const ::std::string& clientip() const;
  void set_clientip(const ::std::string& value);
  #if LANG_CXX11
  void set_clientip(::std::string&& value);
  #endif
  void set_clientip(const char* value);
  void set_clientip(const char* value, size_t size);
  ::std::string* mutable_clientip();
  ::std::string* release_clientip();
  void set_allocated_clientip(::std::string* clientip);

  // bool responce = 1;
  void clear_responce();
  static const int kResponceFieldNumber = 1;
  bool responce() const;
  void set_responce(bool value);

  // int32 ticket = 2;
  void clear_ticket();
  static const int kTicketFieldNumber = 2;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // int32 clientPort = 4;
  void clear_clientport();
  static const int kClientPortFieldNumber = 4;
  ::google::protobuf::int32 clientport() const;
  void set_clientport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ResponceOnGameView)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientip_;
  bool responce_;
  ::google::protobuf::int32 ticket_;
  ::google::protobuf::int32 clientport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StartGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StartGame) */ {
 public:
  StartGame();
  virtual ~StartGame();

  StartGame(const StartGame& from);

  inline StartGame& operator=(const StartGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StartGame(StartGame&& from) noexcept
    : StartGame() {
    *this = ::std::move(from);
  }

  inline StartGame& operator=(StartGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StartGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartGame* internal_default_instance() {
    return reinterpret_cast<const StartGame*>(
               &_StartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StartGame* other);
  friend void swap(StartGame& a, StartGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StartGame* New() const final {
    return CreateMaybeMessage<StartGame>(NULL);
  }

  StartGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StartGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StartGame& from);
  void MergeFrom(const StartGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 ticket = 1;
  void clear_ticket();
  static const int kTicketFieldNumber = 1;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:StartGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ticket_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OneChargeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OneChargeInfo) */ {
 public:
  OneChargeInfo();
  virtual ~OneChargeInfo();

  OneChargeInfo(const OneChargeInfo& from);

  inline OneChargeInfo& operator=(const OneChargeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OneChargeInfo(OneChargeInfo&& from) noexcept
    : OneChargeInfo() {
    *this = ::std::move(from);
  }

  inline OneChargeInfo& operator=(OneChargeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OneChargeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OneChargeInfo* internal_default_instance() {
    return reinterpret_cast<const OneChargeInfo*>(
               &_OneChargeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OneChargeInfo* other);
  friend void swap(OneChargeInfo& a, OneChargeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OneChargeInfo* New() const final {
    return CreateMaybeMessage<OneChargeInfo>(NULL);
  }

  OneChargeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OneChargeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OneChargeInfo& from);
  void MergeFrom(const OneChargeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneChargeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OneChargeInfo_Charge2DType Charge2DType;
  static const Charge2DType ctStatic =
    OneChargeInfo_Charge2DType_ctStatic;
  static const Charge2DType ctDynamic =
    OneChargeInfo_Charge2DType_ctDynamic;
  static inline bool Charge2DType_IsValid(int value) {
    return OneChargeInfo_Charge2DType_IsValid(value);
  }
  static const Charge2DType Charge2DType_MIN =
    OneChargeInfo_Charge2DType_Charge2DType_MIN;
  static const Charge2DType Charge2DType_MAX =
    OneChargeInfo_Charge2DType_Charge2DType_MAX;
  static const int Charge2DType_ARRAYSIZE =
    OneChargeInfo_Charge2DType_Charge2DType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Charge2DType_descriptor() {
    return OneChargeInfo_Charge2DType_descriptor();
  }
  static inline const ::std::string& Charge2DType_Name(Charge2DType value) {
    return OneChargeInfo_Charge2DType_Name(value);
  }
  static inline bool Charge2DType_Parse(const ::std::string& name,
      Charge2DType* value) {
    return OneChargeInfo_Charge2DType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // .OneChargeInfo.Charge2DType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::OneChargeInfo_Charge2DType type() const;
  void set_type(::OneChargeInfo_Charge2DType value);

  // float m = 3;
  void clear_m();
  static const int kMFieldNumber = 3;
  float m() const;
  void set_m(float value);

  // float charge = 4;
  void clear_charge();
  static const int kChargeFieldNumber = 4;
  float charge() const;
  void set_charge(float value);

  // float x = 5;
  void clear_x();
  static const int kXFieldNumber = 5;
  float x() const;
  void set_x(float value);

  // float y = 6;
  void clear_y();
  static const int kYFieldNumber = 6;
  float y() const;
  void set_y(float value);

  // float vx = 7;
  void clear_vx();
  static const int kVxFieldNumber = 7;
  float vx() const;
  void set_vx(float value);

  // float vy = 8;
  void clear_vy();
  static const int kVyFieldNumber = 8;
  float vy() const;
  void set_vy(float value);

  // float fex = 9;
  void clear_fex();
  static const int kFexFieldNumber = 9;
  float fex() const;
  void set_fex(float value);

  // float fey = 10;
  void clear_fey();
  static const int kFeyFieldNumber = 10;
  float fey() const;
  void set_fey(float value);

  // float fbx = 11;
  void clear_fbx();
  static const int kFbxFieldNumber = 11;
  float fbx() const;
  void set_fbx(float value);

  // float fby = 12;
  void clear_fby();
  static const int kFbyFieldNumber = 12;
  float fby() const;
  void set_fby(float value);

  // @@protoc_insertion_point(class_scope:OneChargeInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  int type_;
  float m_;
  float charge_;
  float x_;
  float y_;
  float vx_;
  float vy_;
  float fex_;
  float fey_;
  float fbx_;
  float fby_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShowStruct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShowStruct) */ {
 public:
  ShowStruct();
  virtual ~ShowStruct();

  ShowStruct(const ShowStruct& from);

  inline ShowStruct& operator=(const ShowStruct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShowStruct(ShowStruct&& from) noexcept
    : ShowStruct() {
    *this = ::std::move(from);
  }

  inline ShowStruct& operator=(ShowStruct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShowStruct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShowStruct* internal_default_instance() {
    return reinterpret_cast<const ShowStruct*>(
               &_ShowStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ShowStruct* other);
  friend void swap(ShowStruct& a, ShowStruct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShowStruct* New() const final {
    return CreateMaybeMessage<ShowStruct>(NULL);
  }

  ShowStruct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShowStruct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShowStruct& from);
  void MergeFrom(const ShowStruct& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowStruct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string paletteName = 2;
  void clear_palettename();
  static const int kPaletteNameFieldNumber = 2;
  const ::std::string& palettename() const;
  void set_palettename(const ::std::string& value);
  #if LANG_CXX11
  void set_palettename(::std::string&& value);
  #endif
  void set_palettename(const char* value);
  void set_palettename(const char* value, size_t size);
  ::std::string* mutable_palettename();
  ::std::string* release_palettename();
  void set_allocated_palettename(::std::string* palettename);

  // .ShowPaletteType paletteType = 1;
  void clear_palettetype();
  static const int kPaletteTypeFieldNumber = 1;
  ::ShowPaletteType palettetype() const;
  void set_palettetype(::ShowPaletteType value);

  // @@protoc_insertion_point(class_scope:ShowStruct)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr palettename_;
  int palettetype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SceneGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SceneGeometry) */ {
 public:
  SceneGeometry();
  virtual ~SceneGeometry();

  SceneGeometry(const SceneGeometry& from);

  inline SceneGeometry& operator=(const SceneGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SceneGeometry(SceneGeometry&& from) noexcept
    : SceneGeometry() {
    *this = ::std::move(from);
  }

  inline SceneGeometry& operator=(SceneGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneGeometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SceneGeometry* internal_default_instance() {
    return reinterpret_cast<const SceneGeometry*>(
               &_SceneGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SceneGeometry* other);
  friend void swap(SceneGeometry& a, SceneGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SceneGeometry* New() const final {
    return CreateMaybeMessage<SceneGeometry>(NULL);
  }

  SceneGeometry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SceneGeometry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SceneGeometry& from);
  void MergeFrom(const SceneGeometry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ShowStruct forcesShowStruct = 6;
  bool has_forcesshowstruct() const;
  void clear_forcesshowstruct();
  static const int kForcesShowStructFieldNumber = 6;
  private:
  const ::ShowStruct& _internal_forcesshowstruct() const;
  public:
  const ::ShowStruct& forcesshowstruct() const;
  ::ShowStruct* release_forcesshowstruct();
  ::ShowStruct* mutable_forcesshowstruct();
  void set_allocated_forcesshowstruct(::ShowStruct* forcesshowstruct);

  // .ShowStruct eqPotentialsShowStruct = 7;
  bool has_eqpotentialsshowstruct() const;
  void clear_eqpotentialsshowstruct();
  static const int kEqPotentialsShowStructFieldNumber = 7;
  private:
  const ::ShowStruct& _internal_eqpotentialsshowstruct() const;
  public:
  const ::ShowStruct& eqpotentialsshowstruct() const;
  ::ShowStruct* release_eqpotentialsshowstruct();
  ::ShowStruct* mutable_eqpotentialsshowstruct();
  void set_allocated_eqpotentialsshowstruct(::ShowStruct* eqpotentialsshowstruct);

  // float width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  float width() const;
  void set_width(float value);

  // float height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  float height() const;
  void set_height(float value);

  // float qulon = 3;
  void clear_qulon();
  static const int kQulonFieldNumber = 3;
  float qulon() const;
  void set_qulon(float value);

  // float lightVelocity = 4;
  void clear_lightvelocity();
  static const int kLightVelocityFieldNumber = 4;
  float lightvelocity() const;
  void set_lightvelocity(float value);

  // bool ifMagnetic = 5;
  void clear_ifmagnetic();
  static const int kIfMagneticFieldNumber = 5;
  bool ifmagnetic() const;
  void set_ifmagnetic(bool value);

  // @@protoc_insertion_point(class_scope:SceneGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ShowStruct* forcesshowstruct_;
  ::ShowStruct* eqpotentialsshowstruct_;
  float width_;
  float height_;
  float qulon_;
  float lightvelocity_;
  bool ifmagnetic_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RTCGameClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RTCGameClientRequest) */ {
 public:
  RTCGameClientRequest();
  virtual ~RTCGameClientRequest();

  RTCGameClientRequest(const RTCGameClientRequest& from);

  inline RTCGameClientRequest& operator=(const RTCGameClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RTCGameClientRequest(RTCGameClientRequest&& from) noexcept
    : RTCGameClientRequest() {
    *this = ::std::move(from);
  }

  inline RTCGameClientRequest& operator=(RTCGameClientRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RTCGameClientRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RTCGameClientRequest* internal_default_instance() {
    return reinterpret_cast<const RTCGameClientRequest*>(
               &_RTCGameClientRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RTCGameClientRequest* other);
  friend void swap(RTCGameClientRequest& a, RTCGameClientRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RTCGameClientRequest* New() const final {
    return CreateMaybeMessage<RTCGameClientRequest>(NULL);
  }

  RTCGameClientRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RTCGameClientRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RTCGameClientRequest& from);
  void MergeFrom(const RTCGameClientRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTCGameClientRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RTCGameClientRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RTCGameAdminRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RTCGameAdminRequest) */ {
 public:
  RTCGameAdminRequest();
  virtual ~RTCGameAdminRequest();

  RTCGameAdminRequest(const RTCGameAdminRequest& from);

  inline RTCGameAdminRequest& operator=(const RTCGameAdminRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RTCGameAdminRequest(RTCGameAdminRequest&& from) noexcept
    : RTCGameAdminRequest() {
    *this = ::std::move(from);
  }

  inline RTCGameAdminRequest& operator=(RTCGameAdminRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RTCGameAdminRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RTCGameAdminRequest* internal_default_instance() {
    return reinterpret_cast<const RTCGameAdminRequest*>(
               &_RTCGameAdminRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RTCGameAdminRequest* other);
  friend void swap(RTCGameAdminRequest& a, RTCGameAdminRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RTCGameAdminRequest* New() const final {
    return CreateMaybeMessage<RTCGameAdminRequest>(NULL);
  }

  RTCGameAdminRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RTCGameAdminRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RTCGameAdminRequest& from);
  void MergeFrom(const RTCGameAdminRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTCGameAdminRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string gameName = 1;
  void clear_gamename();
  static const int kGameNameFieldNumber = 1;
  const ::std::string& gamename() const;
  void set_gamename(const ::std::string& value);
  #if LANG_CXX11
  void set_gamename(::std::string&& value);
  #endif
  void set_gamename(const char* value);
  void set_gamename(const char* value, size_t size);
  ::std::string* mutable_gamename();
  ::std::string* release_gamename();
  void set_allocated_gamename(::std::string* gamename);

  // int32 roomSize = 2;
  void clear_roomsize();
  static const int kRoomSizeFieldNumber = 2;
  ::google::protobuf::int32 roomsize() const;
  void set_roomsize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RTCGameAdminRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr gamename_;
  ::google::protobuf::int32 roomsize_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlayGameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PlayGameRequest) */ {
 public:
  PlayGameRequest();
  virtual ~PlayGameRequest();

  PlayGameRequest(const PlayGameRequest& from);

  inline PlayGameRequest& operator=(const PlayGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayGameRequest(PlayGameRequest&& from) noexcept
    : PlayGameRequest() {
    *this = ::std::move(from);
  }

  inline PlayGameRequest& operator=(PlayGameRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayGameRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayGameRequest* internal_default_instance() {
    return reinterpret_cast<const PlayGameRequest*>(
               &_PlayGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PlayGameRequest* other);
  friend void swap(PlayGameRequest& a, PlayGameRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayGameRequest* New() const final {
    return CreateMaybeMessage<PlayGameRequest>(NULL);
  }

  PlayGameRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlayGameRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlayGameRequest& from);
  void MergeFrom(const PlayGameRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayGameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip = 1;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayGameRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ViewGameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ViewGameRequest) */ {
 public:
  ViewGameRequest();
  virtual ~ViewGameRequest();

  ViewGameRequest(const ViewGameRequest& from);

  inline ViewGameRequest& operator=(const ViewGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ViewGameRequest(ViewGameRequest&& from) noexcept
    : ViewGameRequest() {
    *this = ::std::move(from);
  }

  inline ViewGameRequest& operator=(ViewGameRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ViewGameRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ViewGameRequest* internal_default_instance() {
    return reinterpret_cast<const ViewGameRequest*>(
               &_ViewGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ViewGameRequest* other);
  friend void swap(ViewGameRequest& a, ViewGameRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ViewGameRequest* New() const final {
    return CreateMaybeMessage<ViewGameRequest>(NULL);
  }

  ViewGameRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ViewGameRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ViewGameRequest& from);
  void MergeFrom(const ViewGameRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViewGameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip = 1;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ViewGameRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RTCAdmin2ClientOffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RTCAdmin2ClientOffer) */ {
 public:
  RTCAdmin2ClientOffer();
  virtual ~RTCAdmin2ClientOffer();

  RTCAdmin2ClientOffer(const RTCAdmin2ClientOffer& from);

  inline RTCAdmin2ClientOffer& operator=(const RTCAdmin2ClientOffer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RTCAdmin2ClientOffer(RTCAdmin2ClientOffer&& from) noexcept
    : RTCAdmin2ClientOffer() {
    *this = ::std::move(from);
  }

  inline RTCAdmin2ClientOffer& operator=(RTCAdmin2ClientOffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RTCAdmin2ClientOffer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RTCAdmin2ClientOffer* internal_default_instance() {
    return reinterpret_cast<const RTCAdmin2ClientOffer*>(
               &_RTCAdmin2ClientOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RTCAdmin2ClientOffer* other);
  friend void swap(RTCAdmin2ClientOffer& a, RTCAdmin2ClientOffer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RTCAdmin2ClientOffer* New() const final {
    return CreateMaybeMessage<RTCAdmin2ClientOffer>(NULL);
  }

  RTCAdmin2ClientOffer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RTCAdmin2ClientOffer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RTCAdmin2ClientOffer& from);
  void MergeFrom(const RTCAdmin2ClientOffer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTCAdmin2ClientOffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string offer = 2;
  void clear_offer();
  static const int kOfferFieldNumber = 2;
  const ::std::string& offer() const;
  void set_offer(const ::std::string& value);
  #if LANG_CXX11
  void set_offer(::std::string&& value);
  #endif
  void set_offer(const char* value);
  void set_offer(const char* value, size_t size);
  ::std::string* mutable_offer();
  ::std::string* release_offer();
  void set_allocated_offer(::std::string* offer);

  // int32 gameRTCID = 1;
  void clear_gamertcid();
  static const int kGameRTCIDFieldNumber = 1;
  ::google::protobuf::int32 gamertcid() const;
  void set_gamertcid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RTCAdmin2ClientOffer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr offer_;
  ::google::protobuf::int32 gamertcid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RTCClient2AdminAnswer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RTCClient2AdminAnswer) */ {
 public:
  RTCClient2AdminAnswer();
  virtual ~RTCClient2AdminAnswer();

  RTCClient2AdminAnswer(const RTCClient2AdminAnswer& from);

  inline RTCClient2AdminAnswer& operator=(const RTCClient2AdminAnswer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RTCClient2AdminAnswer(RTCClient2AdminAnswer&& from) noexcept
    : RTCClient2AdminAnswer() {
    *this = ::std::move(from);
  }

  inline RTCClient2AdminAnswer& operator=(RTCClient2AdminAnswer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RTCClient2AdminAnswer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RTCClient2AdminAnswer* internal_default_instance() {
    return reinterpret_cast<const RTCClient2AdminAnswer*>(
               &_RTCClient2AdminAnswer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RTCClient2AdminAnswer* other);
  friend void swap(RTCClient2AdminAnswer& a, RTCClient2AdminAnswer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RTCClient2AdminAnswer* New() const final {
    return CreateMaybeMessage<RTCClient2AdminAnswer>(NULL);
  }

  RTCClient2AdminAnswer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RTCClient2AdminAnswer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RTCClient2AdminAnswer& from);
  void MergeFrom(const RTCClient2AdminAnswer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RTCClient2AdminAnswer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string answer = 2;
  void clear_answer();
  static const int kAnswerFieldNumber = 2;
  const ::std::string& answer() const;
  void set_answer(const ::std::string& value);
  #if LANG_CXX11
  void set_answer(::std::string&& value);
  #endif
  void set_answer(const char* value);
  void set_answer(const char* value, size_t size);
  ::std::string* mutable_answer();
  ::std::string* release_answer();
  void set_allocated_answer(::std::string* answer);

  // int32 gameRTCID = 1;
  void clear_gamertcid();
  static const int kGameRTCIDFieldNumber = 1;
  ::google::protobuf::int32 gamertcid() const;
  void set_gamertcid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RTCClient2AdminAnswer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr answer_;
  ::google::protobuf::int32 gamertcid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientQueryRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ClientQueryRequest) */ {
 public:
  ClientQueryRequest();
  virtual ~ClientQueryRequest();

  ClientQueryRequest(const ClientQueryRequest& from);

  inline ClientQueryRequest& operator=(const ClientQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientQueryRequest(ClientQueryRequest&& from) noexcept
    : ClientQueryRequest() {
    *this = ::std::move(from);
  }

  inline ClientQueryRequest& operator=(ClientQueryRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientQueryRequest& default_instance();

  enum MessageCase {
    kPlayRequest = 1,
    kViewRequest = 2,
    kRtcAdminRequest = 3,
    kRtcClientRequest = 4,
    kRtcOffer = 5,
    kRtcAnswer = 6,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientQueryRequest* internal_default_instance() {
    return reinterpret_cast<const ClientQueryRequest*>(
               &_ClientQueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ClientQueryRequest* other);
  friend void swap(ClientQueryRequest& a, ClientQueryRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientQueryRequest* New() const final {
    return CreateMaybeMessage<ClientQueryRequest>(NULL);
  }

  ClientQueryRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientQueryRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientQueryRequest& from);
  void MergeFrom(const ClientQueryRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientQueryRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .PlayGameRequest playRequest = 1;
  bool has_playrequest() const;
  void clear_playrequest();
  static const int kPlayRequestFieldNumber = 1;
  private:
  const ::PlayGameRequest& _internal_playrequest() const;
  public:
  const ::PlayGameRequest& playrequest() const;
  ::PlayGameRequest* release_playrequest();
  ::PlayGameRequest* mutable_playrequest();
  void set_allocated_playrequest(::PlayGameRequest* playrequest);

  // .ViewGameRequest viewRequest = 2;
  bool has_viewrequest() const;
  void clear_viewrequest();
  static const int kViewRequestFieldNumber = 2;
  private:
  const ::ViewGameRequest& _internal_viewrequest() const;
  public:
  const ::ViewGameRequest& viewrequest() const;
  ::ViewGameRequest* release_viewrequest();
  ::ViewGameRequest* mutable_viewrequest();
  void set_allocated_viewrequest(::ViewGameRequest* viewrequest);

  // .RTCGameAdminRequest rtcAdminRequest = 3;
  bool has_rtcadminrequest() const;
  void clear_rtcadminrequest();
  static const int kRtcAdminRequestFieldNumber = 3;
  private:
  const ::RTCGameAdminRequest& _internal_rtcadminrequest() const;
  public:
  const ::RTCGameAdminRequest& rtcadminrequest() const;
  ::RTCGameAdminRequest* release_rtcadminrequest();
  ::RTCGameAdminRequest* mutable_rtcadminrequest();
  void set_allocated_rtcadminrequest(::RTCGameAdminRequest* rtcadminrequest);

  // .RTCGameClientRequest rtcClientRequest = 4;
  bool has_rtcclientrequest() const;
  void clear_rtcclientrequest();
  static const int kRtcClientRequestFieldNumber = 4;
  private:
  const ::RTCGameClientRequest& _internal_rtcclientrequest() const;
  public:
  const ::RTCGameClientRequest& rtcclientrequest() const;
  ::RTCGameClientRequest* release_rtcclientrequest();
  ::RTCGameClientRequest* mutable_rtcclientrequest();
  void set_allocated_rtcclientrequest(::RTCGameClientRequest* rtcclientrequest);

  // .RTCAdmin2ClientOffer rtcOffer = 5;
  bool has_rtcoffer() const;
  void clear_rtcoffer();
  static const int kRtcOfferFieldNumber = 5;
  private:
  const ::RTCAdmin2ClientOffer& _internal_rtcoffer() const;
  public:
  const ::RTCAdmin2ClientOffer& rtcoffer() const;
  ::RTCAdmin2ClientOffer* release_rtcoffer();
  ::RTCAdmin2ClientOffer* mutable_rtcoffer();
  void set_allocated_rtcoffer(::RTCAdmin2ClientOffer* rtcoffer);

  // .RTCClient2AdminAnswer rtcAnswer = 6;
  bool has_rtcanswer() const;
  void clear_rtcanswer();
  static const int kRtcAnswerFieldNumber = 6;
  private:
  const ::RTCClient2AdminAnswer& _internal_rtcanswer() const;
  public:
  const ::RTCClient2AdminAnswer& rtcanswer() const;
  ::RTCClient2AdminAnswer* release_rtcanswer();
  ::RTCClient2AdminAnswer* mutable_rtcanswer();
  void set_allocated_rtcanswer(::RTCClient2AdminAnswer* rtcanswer);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:ClientQueryRequest)
 private:
  void set_has_playrequest();
  void set_has_viewrequest();
  void set_has_rtcadminrequest();
  void set_has_rtcclientrequest();
  void set_has_rtcoffer();
  void set_has_rtcanswer();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::PlayGameRequest* playrequest_;
    ::ViewGameRequest* viewrequest_;
    ::RTCGameAdminRequest* rtcadminrequest_;
    ::RTCGameClientRequest* rtcclientrequest_;
    ::RTCAdmin2ClientOffer* rtcoffer_;
    ::RTCClient2AdminAnswer* rtcanswer_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomToClient : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomToClient) */ {
 public:
  RoomToClient();
  virtual ~RoomToClient();

  RoomToClient(const RoomToClient& from);

  inline RoomToClient& operator=(const RoomToClient& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomToClient(RoomToClient&& from) noexcept
    : RoomToClient() {
    *this = ::std::move(from);
  }

  inline RoomToClient& operator=(RoomToClient&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomToClient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomToClient* internal_default_instance() {
    return reinterpret_cast<const RoomToClient*>(
               &_RoomToClient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RoomToClient* other);
  friend void swap(RoomToClient& a, RoomToClient& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomToClient* New() const final {
    return CreateMaybeMessage<RoomToClient>(NULL);
  }

  RoomToClient* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomToClient>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomToClient& from);
  void MergeFrom(const RoomToClient& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomToClient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OneChargeInfo chargeInfo = 2;
  int chargeinfo_size() const;
  void clear_chargeinfo();
  static const int kChargeInfoFieldNumber = 2;
  ::OneChargeInfo* mutable_chargeinfo(int index);
  ::google::protobuf::RepeatedPtrField< ::OneChargeInfo >*
      mutable_chargeinfo();
  const ::OneChargeInfo& chargeinfo(int index) const;
  ::OneChargeInfo* add_chargeinfo();
  const ::google::protobuf::RepeatedPtrField< ::OneChargeInfo >&
      chargeinfo() const;

  // int32 packetId = 1;
  void clear_packetid();
  static const int kPacketIdFieldNumber = 1;
  ::google::protobuf::int32 packetid() const;
  void set_packetid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RoomToClient)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::OneChargeInfo > chargeinfo_;
  ::google::protobuf::int32 packetid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameState) */ {
 public:
  GameState();
  virtual ~GameState();

  GameState(const GameState& from);

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameState(GameState&& from) noexcept
    : GameState() {
    *this = ::std::move(from);
  }

  inline GameState& operator=(GameState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameState* internal_default_instance() {
    return reinterpret_cast<const GameState*>(
               &_GameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GameState* other);
  friend void swap(GameState& a, GameState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameState* New() const final {
    return CreateMaybeMessage<GameState>(NULL);
  }

  GameState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .RoomInfo roomInfo = 2;
  bool has_roominfo() const;
  void clear_roominfo();
  static const int kRoomInfoFieldNumber = 2;
  private:
  const ::RoomInfo& _internal_roominfo() const;
  public:
  const ::RoomInfo& roominfo() const;
  ::RoomInfo* release_roominfo();
  ::RoomInfo* mutable_roominfo();
  void set_allocated_roominfo(::RoomInfo* roominfo);

  // int32 roomPort = 1;
  void clear_roomport();
  static const int kRoomPortFieldNumber = 1;
  ::google::protobuf::int32 roomport() const;
  void set_roomport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::RoomInfo* roominfo_;
  ::google::protobuf::int32 roomport_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameInfo) */ {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameInfo(GameInfo&& from) noexcept
    : GameInfo() {
    *this = ::std::move(from);
  }

  inline GameInfo& operator=(GameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInfo* internal_default_instance() {
    return reinterpret_cast<const GameInfo*>(
               &_GameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GameInfo* other);
  friend void swap(GameInfo& a, GameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameInfo* New() const final {
    return CreateMaybeMessage<GameInfo>(NULL);
  }

  GameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .SceneGeometry geometry = 1;
  bool has_geometry() const;
  void clear_geometry();
  static const int kGeometryFieldNumber = 1;
  private:
  const ::SceneGeometry& _internal_geometry() const;
  public:
  const ::SceneGeometry& geometry() const;
  ::SceneGeometry* release_geometry();
  ::SceneGeometry* mutable_geometry();
  void set_allocated_geometry(::SceneGeometry* geometry);

  // int32 currentChargeId = 2;
  void clear_currentchargeid();
  static const int kCurrentChargeIdFieldNumber = 2;
  ::google::protobuf::int32 currentchargeid() const;
  void set_currentchargeid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::SceneGeometry* geometry_;
  ::google::protobuf::int32 currentchargeid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomWrappedToClientMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomWrappedToClientMessage) */ {
 public:
  RoomWrappedToClientMessage();
  virtual ~RoomWrappedToClientMessage();

  RoomWrappedToClientMessage(const RoomWrappedToClientMessage& from);

  inline RoomWrappedToClientMessage& operator=(const RoomWrappedToClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomWrappedToClientMessage(RoomWrappedToClientMessage&& from) noexcept
    : RoomWrappedToClientMessage() {
    *this = ::std::move(from);
  }

  inline RoomWrappedToClientMessage& operator=(RoomWrappedToClientMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomWrappedToClientMessage& default_instance();

  enum MessageCase {
    kRoomToClient = 1,
    kGameInfo = 2,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomWrappedToClientMessage* internal_default_instance() {
    return reinterpret_cast<const RoomWrappedToClientMessage*>(
               &_RoomWrappedToClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(RoomWrappedToClientMessage* other);
  friend void swap(RoomWrappedToClientMessage& a, RoomWrappedToClientMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomWrappedToClientMessage* New() const final {
    return CreateMaybeMessage<RoomWrappedToClientMessage>(NULL);
  }

  RoomWrappedToClientMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomWrappedToClientMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomWrappedToClientMessage& from);
  void MergeFrom(const RoomWrappedToClientMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomWrappedToClientMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .RoomToClient roomToClient = 1;
  bool has_roomtoclient() const;
  void clear_roomtoclient();
  static const int kRoomToClientFieldNumber = 1;
  private:
  const ::RoomToClient& _internal_roomtoclient() const;
  public:
  const ::RoomToClient& roomtoclient() const;
  ::RoomToClient* release_roomtoclient();
  ::RoomToClient* mutable_roomtoclient();
  void set_allocated_roomtoclient(::RoomToClient* roomtoclient);

  // .GameInfo gameInfo = 2;
  bool has_gameinfo() const;
  void clear_gameinfo();
  static const int kGameInfoFieldNumber = 2;
  private:
  const ::GameInfo& _internal_gameinfo() const;
  public:
  const ::GameInfo& gameinfo() const;
  ::GameInfo* release_gameinfo();
  ::GameInfo* mutable_gameinfo();
  void set_allocated_gameinfo(::GameInfo* gameinfo);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:RoomWrappedToClientMessage)
 private:
  void set_has_roomtoclient();
  void set_has_gameinfo();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::RoomToClient* roomtoclient_;
    ::GameInfo* gameinfo_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WebRTCGameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WebRTCGameInfo) */ {
 public:
  WebRTCGameInfo();
  virtual ~WebRTCGameInfo();

  WebRTCGameInfo(const WebRTCGameInfo& from);

  inline WebRTCGameInfo& operator=(const WebRTCGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WebRTCGameInfo(WebRTCGameInfo&& from) noexcept
    : WebRTCGameInfo() {
    *this = ::std::move(from);
  }

  inline WebRTCGameInfo& operator=(WebRTCGameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WebRTCGameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WebRTCGameInfo* internal_default_instance() {
    return reinterpret_cast<const WebRTCGameInfo*>(
               &_WebRTCGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(WebRTCGameInfo* other);
  friend void swap(WebRTCGameInfo& a, WebRTCGameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WebRTCGameInfo* New() const final {
    return CreateMaybeMessage<WebRTCGameInfo>(NULL);
  }

  WebRTCGameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WebRTCGameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WebRTCGameInfo& from);
  void MergeFrom(const WebRTCGameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebRTCGameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string url = 1;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // string forcePalette = 3;
  void clear_forcepalette();
  static const int kForcePaletteFieldNumber = 3;
  const ::std::string& forcepalette() const;
  void set_forcepalette(const ::std::string& value);
  #if LANG_CXX11
  void set_forcepalette(::std::string&& value);
  #endif
  void set_forcepalette(const char* value);
  void set_forcepalette(const char* value, size_t size);
  ::std::string* mutable_forcepalette();
  ::std::string* release_forcepalette();
  void set_allocated_forcepalette(::std::string* forcepalette);

  // string eqPotPalette = 4;
  void clear_eqpotpalette();
  static const int kEqPotPaletteFieldNumber = 4;
  const ::std::string& eqpotpalette() const;
  void set_eqpotpalette(const ::std::string& value);
  #if LANG_CXX11
  void set_eqpotpalette(::std::string&& value);
  #endif
  void set_eqpotpalette(const char* value);
  void set_eqpotpalette(const char* value, size_t size);
  ::std::string* mutable_eqpotpalette();
  ::std::string* release_eqpotpalette();
  void set_allocated_eqpotpalette(::std::string* eqpotpalette);

  // int32 gameid = 2;
  void clear_gameid();
  static const int kGameidFieldNumber = 2;
  ::google::protobuf::int32 gameid() const;
  void set_gameid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WebRTCGameInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr forcepalette_;
  ::google::protobuf::internal::ArenaStringPtr eqpotpalette_;
  ::google::protobuf::int32 gameid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WebRTCAdminToClientMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WebRTCAdminToClientMessage) */ {
 public:
  WebRTCAdminToClientMessage();
  virtual ~WebRTCAdminToClientMessage();

  WebRTCAdminToClientMessage(const WebRTCAdminToClientMessage& from);

  inline WebRTCAdminToClientMessage& operator=(const WebRTCAdminToClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WebRTCAdminToClientMessage(WebRTCAdminToClientMessage&& from) noexcept
    : WebRTCAdminToClientMessage() {
    *this = ::std::move(from);
  }

  inline WebRTCAdminToClientMessage& operator=(WebRTCAdminToClientMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WebRTCAdminToClientMessage& default_instance();

  enum MessageCase {
    kRtcGameInfo = 1,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WebRTCAdminToClientMessage* internal_default_instance() {
    return reinterpret_cast<const WebRTCAdminToClientMessage*>(
               &_WebRTCAdminToClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(WebRTCAdminToClientMessage* other);
  friend void swap(WebRTCAdminToClientMessage& a, WebRTCAdminToClientMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WebRTCAdminToClientMessage* New() const final {
    return CreateMaybeMessage<WebRTCAdminToClientMessage>(NULL);
  }

  WebRTCAdminToClientMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WebRTCAdminToClientMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WebRTCAdminToClientMessage& from);
  void MergeFrom(const WebRTCAdminToClientMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebRTCAdminToClientMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .WebRTCGameInfo rtcGameInfo = 1;
  bool has_rtcgameinfo() const;
  void clear_rtcgameinfo();
  static const int kRtcGameInfoFieldNumber = 1;
  private:
  const ::WebRTCGameInfo& _internal_rtcgameinfo() const;
  public:
  const ::WebRTCGameInfo& rtcgameinfo() const;
  ::WebRTCGameInfo* release_rtcgameinfo();
  ::WebRTCGameInfo* mutable_rtcgameinfo();
  void set_allocated_rtcgameinfo(::WebRTCGameInfo* rtcgameinfo);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:WebRTCAdminToClientMessage)
 private:
  void set_has_rtcgameinfo();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::WebRTCGameInfo* rtcgameinfo_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomWrappedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RoomWrappedMessage) */ {
 public:
  RoomWrappedMessage();
  virtual ~RoomWrappedMessage();

  RoomWrappedMessage(const RoomWrappedMessage& from);

  inline RoomWrappedMessage& operator=(const RoomWrappedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomWrappedMessage(RoomWrappedMessage&& from) noexcept
    : RoomWrappedMessage() {
    *this = ::std::move(from);
  }

  inline RoomWrappedMessage& operator=(RoomWrappedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomWrappedMessage& default_instance();

  enum MessageCase {
    kRoomInfo = 1,
    kResponceInvitation = 2,
    kResponceView = 3,
    kStartGame = 4,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomWrappedMessage* internal_default_instance() {
    return reinterpret_cast<const RoomWrappedMessage*>(
               &_RoomWrappedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RoomWrappedMessage* other);
  friend void swap(RoomWrappedMessage& a, RoomWrappedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomWrappedMessage* New() const final {
    return CreateMaybeMessage<RoomWrappedMessage>(NULL);
  }

  RoomWrappedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomWrappedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomWrappedMessage& from);
  void MergeFrom(const RoomWrappedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomWrappedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .RoomInfo roomInfo = 1;
  bool has_roominfo() const;
  void clear_roominfo();
  static const int kRoomInfoFieldNumber = 1;
  private:
  const ::RoomInfo& _internal_roominfo() const;
  public:
  const ::RoomInfo& roominfo() const;
  ::RoomInfo* release_roominfo();
  ::RoomInfo* mutable_roominfo();
  void set_allocated_roominfo(::RoomInfo* roominfo);

  // .ResponceOnGameInvitation responceInvitation = 2;
  bool has_responceinvitation() const;
  void clear_responceinvitation();
  static const int kResponceInvitationFieldNumber = 2;
  private:
  const ::ResponceOnGameInvitation& _internal_responceinvitation() const;
  public:
  const ::ResponceOnGameInvitation& responceinvitation() const;
  ::ResponceOnGameInvitation* release_responceinvitation();
  ::ResponceOnGameInvitation* mutable_responceinvitation();
  void set_allocated_responceinvitation(::ResponceOnGameInvitation* responceinvitation);

  // .ResponceOnGameView responceView = 3;
  bool has_responceview() const;
  void clear_responceview();
  static const int kResponceViewFieldNumber = 3;
  private:
  const ::ResponceOnGameView& _internal_responceview() const;
  public:
  const ::ResponceOnGameView& responceview() const;
  ::ResponceOnGameView* release_responceview();
  ::ResponceOnGameView* mutable_responceview();
  void set_allocated_responceview(::ResponceOnGameView* responceview);

  // .StartGame startGame = 4;
  bool has_startgame() const;
  void clear_startgame();
  static const int kStartGameFieldNumber = 4;
  private:
  const ::StartGame& _internal_startgame() const;
  public:
  const ::StartGame& startgame() const;
  ::StartGame* release_startgame();
  ::StartGame* mutable_startgame();
  void set_allocated_startgame(::StartGame* startgame);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:RoomWrappedMessage)
 private:
  void set_has_roominfo();
  void set_has_responceinvitation();
  void set_has_responceview();
  void set_has_startgame();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::RoomInfo* roominfo_;
    ::ResponceOnGameInvitation* responceinvitation_;
    ::ResponceOnGameView* responceview_;
    ::StartGame* startgame_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InvitationToPlayGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InvitationToPlayGame) */ {
 public:
  InvitationToPlayGame();
  virtual ~InvitationToPlayGame();

  InvitationToPlayGame(const InvitationToPlayGame& from);

  inline InvitationToPlayGame& operator=(const InvitationToPlayGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InvitationToPlayGame(InvitationToPlayGame&& from) noexcept
    : InvitationToPlayGame() {
    *this = ::std::move(from);
  }

  inline InvitationToPlayGame& operator=(InvitationToPlayGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvitationToPlayGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvitationToPlayGame* internal_default_instance() {
    return reinterpret_cast<const InvitationToPlayGame*>(
               &_InvitationToPlayGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(InvitationToPlayGame* other);
  friend void swap(InvitationToPlayGame& a, InvitationToPlayGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InvitationToPlayGame* New() const final {
    return CreateMaybeMessage<InvitationToPlayGame>(NULL);
  }

  InvitationToPlayGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InvitationToPlayGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InvitationToPlayGame& from);
  void MergeFrom(const InvitationToPlayGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvitationToPlayGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientIp = 2;
  void clear_clientip();
  static const int kClientIpFieldNumber = 2;
  const ::std::string& clientip() const;
  void set_clientip(const ::std::string& value);
  #if LANG_CXX11
  void set_clientip(::std::string&& value);
  #endif
  void set_clientip(const char* value);
  void set_clientip(const char* value, size_t size);
  ::std::string* mutable_clientip();
  ::std::string* release_clientip();
  void set_allocated_clientip(::std::string* clientip);

  // int32 clientPort = 1;
  void clear_clientport();
  static const int kClientPortFieldNumber = 1;
  ::google::protobuf::int32 clientport() const;
  void set_clientport(::google::protobuf::int32 value);

  // int32 ticket = 3;
  void clear_ticket();
  static const int kTicketFieldNumber = 3;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:InvitationToPlayGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientip_;
  ::google::protobuf::int32 clientport_;
  ::google::protobuf::int32 ticket_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InvitationToViewGame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:InvitationToViewGame) */ {
 public:
  InvitationToViewGame();
  virtual ~InvitationToViewGame();

  InvitationToViewGame(const InvitationToViewGame& from);

  inline InvitationToViewGame& operator=(const InvitationToViewGame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InvitationToViewGame(InvitationToViewGame&& from) noexcept
    : InvitationToViewGame() {
    *this = ::std::move(from);
  }

  inline InvitationToViewGame& operator=(InvitationToViewGame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvitationToViewGame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvitationToViewGame* internal_default_instance() {
    return reinterpret_cast<const InvitationToViewGame*>(
               &_InvitationToViewGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(InvitationToViewGame* other);
  friend void swap(InvitationToViewGame& a, InvitationToViewGame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InvitationToViewGame* New() const final {
    return CreateMaybeMessage<InvitationToViewGame>(NULL);
  }

  InvitationToViewGame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InvitationToViewGame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InvitationToViewGame& from);
  void MergeFrom(const InvitationToViewGame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvitationToViewGame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string clientIp = 2;
  void clear_clientip();
  static const int kClientIpFieldNumber = 2;
  const ::std::string& clientip() const;
  void set_clientip(const ::std::string& value);
  #if LANG_CXX11
  void set_clientip(::std::string&& value);
  #endif
  void set_clientip(const char* value);
  void set_clientip(const char* value, size_t size);
  ::std::string* mutable_clientip();
  ::std::string* release_clientip();
  void set_allocated_clientip(::std::string* clientip);

  // int32 clientPort = 1;
  void clear_clientport();
  static const int kClientPortFieldNumber = 1;
  ::google::protobuf::int32 clientport() const;
  void set_clientport(::google::protobuf::int32 value);

  // int32 ticket = 3;
  void clear_ticket();
  static const int kTicketFieldNumber = 3;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:InvitationToViewGame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr clientip_;
  ::google::protobuf::int32 clientport_;
  ::google::protobuf::int32 ticket_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListenerToClientGamesStates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListenerToClientGamesStates) */ {
 public:
  ListenerToClientGamesStates();
  virtual ~ListenerToClientGamesStates();

  ListenerToClientGamesStates(const ListenerToClientGamesStates& from);

  inline ListenerToClientGamesStates& operator=(const ListenerToClientGamesStates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListenerToClientGamesStates(ListenerToClientGamesStates&& from) noexcept
    : ListenerToClientGamesStates() {
    *this = ::std::move(from);
  }

  inline ListenerToClientGamesStates& operator=(ListenerToClientGamesStates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenerToClientGamesStates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListenerToClientGamesStates* internal_default_instance() {
    return reinterpret_cast<const ListenerToClientGamesStates*>(
               &_ListenerToClientGamesStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ListenerToClientGamesStates* other);
  friend void swap(ListenerToClientGamesStates& a, ListenerToClientGamesStates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListenerToClientGamesStates* New() const final {
    return CreateMaybeMessage<ListenerToClientGamesStates>(NULL);
  }

  ListenerToClientGamesStates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListenerToClientGamesStates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListenerToClientGamesStates& from);
  void MergeFrom(const ListenerToClientGamesStates& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenerToClientGamesStates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .GameState gameState = 1;
  int gamestate_size() const;
  void clear_gamestate();
  static const int kGameStateFieldNumber = 1;
  ::GameState* mutable_gamestate(int index);
  ::google::protobuf::RepeatedPtrField< ::GameState >*
      mutable_gamestate();
  const ::GameState& gamestate(int index) const;
  ::GameState* add_gamestate();
  const ::google::protobuf::RepeatedPtrField< ::GameState >&
      gamestate() const;

  // @@protoc_insertion_point(class_scope:ListenerToClientGamesStates)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::GameState > gamestate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rtcGameState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rtcGameState) */ {
 public:
  rtcGameState();
  virtual ~rtcGameState();

  rtcGameState(const rtcGameState& from);

  inline rtcGameState& operator=(const rtcGameState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rtcGameState(rtcGameState&& from) noexcept
    : rtcGameState() {
    *this = ::std::move(from);
  }

  inline rtcGameState& operator=(rtcGameState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const rtcGameState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rtcGameState* internal_default_instance() {
    return reinterpret_cast<const rtcGameState*>(
               &_rtcGameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(rtcGameState* other);
  friend void swap(rtcGameState& a, rtcGameState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rtcGameState* New() const final {
    return CreateMaybeMessage<rtcGameState>(NULL);
  }

  rtcGameState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<rtcGameState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const rtcGameState& from);
  void MergeFrom(const rtcGameState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rtcGameState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string gameName = 2;
  void clear_gamename();
  static const int kGameNameFieldNumber = 2;
  const ::std::string& gamename() const;
  void set_gamename(const ::std::string& value);
  #if LANG_CXX11
  void set_gamename(::std::string&& value);
  #endif
  void set_gamename(const char* value);
  void set_gamename(const char* value, size_t size);
  ::std::string* mutable_gamename();
  ::std::string* release_gamename();
  void set_allocated_gamename(::std::string* gamename);

  // int32 gameRTCID = 1;
  void clear_gamertcid();
  static const int kGameRTCIDFieldNumber = 1;
  ::google::protobuf::int32 gamertcid() const;
  void set_gamertcid(::google::protobuf::int32 value);

  // int32 roomSize = 3;
  void clear_roomsize();
  static const int kRoomSizeFieldNumber = 3;
  ::google::protobuf::int32 roomsize() const;
  void set_roomsize(::google::protobuf::int32 value);

  // int32 currentPlayersCount = 4;
  void clear_currentplayerscount();
  static const int kCurrentPlayersCountFieldNumber = 4;
  ::google::protobuf::int32 currentplayerscount() const;
  void set_currentplayerscount(::google::protobuf::int32 value);

  // .WebRTCPlayerStatus playerStatus = 5;
  void clear_playerstatus();
  static const int kPlayerStatusFieldNumber = 5;
  ::WebRTCPlayerStatus playerstatus() const;
  void set_playerstatus(::WebRTCPlayerStatus value);

  // @@protoc_insertion_point(class_scope:rtcGameState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr gamename_;
  ::google::protobuf::int32 gamertcid_;
  ::google::protobuf::int32 roomsize_;
  ::google::protobuf::int32 currentplayerscount_;
  int playerstatus_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListenerToClientsWebRTCGamesStates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListenerToClientsWebRTCGamesStates) */ {
 public:
  ListenerToClientsWebRTCGamesStates();
  virtual ~ListenerToClientsWebRTCGamesStates();

  ListenerToClientsWebRTCGamesStates(const ListenerToClientsWebRTCGamesStates& from);

  inline ListenerToClientsWebRTCGamesStates& operator=(const ListenerToClientsWebRTCGamesStates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListenerToClientsWebRTCGamesStates(ListenerToClientsWebRTCGamesStates&& from) noexcept
    : ListenerToClientsWebRTCGamesStates() {
    *this = ::std::move(from);
  }

  inline ListenerToClientsWebRTCGamesStates& operator=(ListenerToClientsWebRTCGamesStates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenerToClientsWebRTCGamesStates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListenerToClientsWebRTCGamesStates* internal_default_instance() {
    return reinterpret_cast<const ListenerToClientsWebRTCGamesStates*>(
               &_ListenerToClientsWebRTCGamesStates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ListenerToClientsWebRTCGamesStates* other);
  friend void swap(ListenerToClientsWebRTCGamesStates& a, ListenerToClientsWebRTCGamesStates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListenerToClientsWebRTCGamesStates* New() const final {
    return CreateMaybeMessage<ListenerToClientsWebRTCGamesStates>(NULL);
  }

  ListenerToClientsWebRTCGamesStates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListenerToClientsWebRTCGamesStates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListenerToClientsWebRTCGamesStates& from);
  void MergeFrom(const ListenerToClientsWebRTCGamesStates& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenerToClientsWebRTCGamesStates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rtcGameState rtcState = 1;
  int rtcstate_size() const;
  void clear_rtcstate();
  static const int kRtcStateFieldNumber = 1;
  ::rtcGameState* mutable_rtcstate(int index);
  ::google::protobuf::RepeatedPtrField< ::rtcGameState >*
      mutable_rtcstate();
  const ::rtcGameState& rtcstate(int index) const;
  ::rtcGameState* add_rtcstate();
  const ::google::protobuf::RepeatedPtrField< ::rtcGameState >&
      rtcstate() const;

  // @@protoc_insertion_point(class_scope:ListenerToClientsWebRTCGamesStates)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::rtcGameState > rtcstate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListenerToClientsWebRTCRefuse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListenerToClientsWebRTCRefuse) */ {
 public:
  ListenerToClientsWebRTCRefuse();
  virtual ~ListenerToClientsWebRTCRefuse();

  ListenerToClientsWebRTCRefuse(const ListenerToClientsWebRTCRefuse& from);

  inline ListenerToClientsWebRTCRefuse& operator=(const ListenerToClientsWebRTCRefuse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListenerToClientsWebRTCRefuse(ListenerToClientsWebRTCRefuse&& from) noexcept
    : ListenerToClientsWebRTCRefuse() {
    *this = ::std::move(from);
  }

  inline ListenerToClientsWebRTCRefuse& operator=(ListenerToClientsWebRTCRefuse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenerToClientsWebRTCRefuse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListenerToClientsWebRTCRefuse* internal_default_instance() {
    return reinterpret_cast<const ListenerToClientsWebRTCRefuse*>(
               &_ListenerToClientsWebRTCRefuse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ListenerToClientsWebRTCRefuse* other);
  friend void swap(ListenerToClientsWebRTCRefuse& a, ListenerToClientsWebRTCRefuse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListenerToClientsWebRTCRefuse* New() const final {
    return CreateMaybeMessage<ListenerToClientsWebRTCRefuse>(NULL);
  }

  ListenerToClientsWebRTCRefuse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListenerToClientsWebRTCRefuse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListenerToClientsWebRTCRefuse& from);
  void MergeFrom(const ListenerToClientsWebRTCRefuse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenerToClientsWebRTCRefuse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 gameRTCID = 1;
  void clear_gamertcid();
  static const int kGameRTCIDFieldNumber = 1;
  ::google::protobuf::int32 gamertcid() const;
  void set_gamertcid(::google::protobuf::int32 value);

  // .WebRTCGameRefuseReasons refuseReason = 2;
  void clear_refusereason();
  static const int kRefuseReasonFieldNumber = 2;
  ::WebRTCGameRefuseReasons refusereason() const;
  void set_refusereason(::WebRTCGameRefuseReasons value);

  // @@protoc_insertion_point(class_scope:ListenerToClientsWebRTCRefuse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 gamertcid_;
  int refusereason_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListenerToClientWrappedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ListenerToClientWrappedMessage) */ {
 public:
  ListenerToClientWrappedMessage();
  virtual ~ListenerToClientWrappedMessage();

  ListenerToClientWrappedMessage(const ListenerToClientWrappedMessage& from);

  inline ListenerToClientWrappedMessage& operator=(const ListenerToClientWrappedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListenerToClientWrappedMessage(ListenerToClientWrappedMessage&& from) noexcept
    : ListenerToClientWrappedMessage() {
    *this = ::std::move(from);
  }

  inline ListenerToClientWrappedMessage& operator=(ListenerToClientWrappedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenerToClientWrappedMessage& default_instance();

  enum MessageCase {
    kInvitationToPlay = 1,
    kStates = 2,
    kInvitationToView = 3,
    kRtcStates = 4,
    kRtcRefuse = 5,
    kRtcOffer = 6,
    kRtcAnswer = 7,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListenerToClientWrappedMessage* internal_default_instance() {
    return reinterpret_cast<const ListenerToClientWrappedMessage*>(
               &_ListenerToClientWrappedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ListenerToClientWrappedMessage* other);
  friend void swap(ListenerToClientWrappedMessage& a, ListenerToClientWrappedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListenerToClientWrappedMessage* New() const final {
    return CreateMaybeMessage<ListenerToClientWrappedMessage>(NULL);
  }

  ListenerToClientWrappedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListenerToClientWrappedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListenerToClientWrappedMessage& from);
  void MergeFrom(const ListenerToClientWrappedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListenerToClientWrappedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .InvitationToPlayGame invitationToPlay = 1;
  bool has_invitationtoplay() const;
  void clear_invitationtoplay();
  static const int kInvitationToPlayFieldNumber = 1;
  private:
  const ::InvitationToPlayGame& _internal_invitationtoplay() const;
  public:
  const ::InvitationToPlayGame& invitationtoplay() const;
  ::InvitationToPlayGame* release_invitationtoplay();
  ::InvitationToPlayGame* mutable_invitationtoplay();
  void set_allocated_invitationtoplay(::InvitationToPlayGame* invitationtoplay);

  // .ListenerToClientGamesStates states = 2;
  bool has_states() const;
  void clear_states();
  static const int kStatesFieldNumber = 2;
  private:
  const ::ListenerToClientGamesStates& _internal_states() const;
  public:
  const ::ListenerToClientGamesStates& states() const;
  ::ListenerToClientGamesStates* release_states();
  ::ListenerToClientGamesStates* mutable_states();
  void set_allocated_states(::ListenerToClientGamesStates* states);

  // .InvitationToViewGame invitationToView = 3;
  bool has_invitationtoview() const;
  void clear_invitationtoview();
  static const int kInvitationToViewFieldNumber = 3;
  private:
  const ::InvitationToViewGame& _internal_invitationtoview() const;
  public:
  const ::InvitationToViewGame& invitationtoview() const;
  ::InvitationToViewGame* release_invitationtoview();
  ::InvitationToViewGame* mutable_invitationtoview();
  void set_allocated_invitationtoview(::InvitationToViewGame* invitationtoview);

  // .ListenerToClientsWebRTCGamesStates rtcStates = 4;
  bool has_rtcstates() const;
  void clear_rtcstates();
  static const int kRtcStatesFieldNumber = 4;
  private:
  const ::ListenerToClientsWebRTCGamesStates& _internal_rtcstates() const;
  public:
  const ::ListenerToClientsWebRTCGamesStates& rtcstates() const;
  ::ListenerToClientsWebRTCGamesStates* release_rtcstates();
  ::ListenerToClientsWebRTCGamesStates* mutable_rtcstates();
  void set_allocated_rtcstates(::ListenerToClientsWebRTCGamesStates* rtcstates);

  // .ListenerToClientsWebRTCRefuse rtcRefuse = 5;
  bool has_rtcrefuse() const;
  void clear_rtcrefuse();
  static const int kRtcRefuseFieldNumber = 5;
  private:
  const ::ListenerToClientsWebRTCRefuse& _internal_rtcrefuse() const;
  public:
  const ::ListenerToClientsWebRTCRefuse& rtcrefuse() const;
  ::ListenerToClientsWebRTCRefuse* release_rtcrefuse();
  ::ListenerToClientsWebRTCRefuse* mutable_rtcrefuse();
  void set_allocated_rtcrefuse(::ListenerToClientsWebRTCRefuse* rtcrefuse);

  // .RTCAdmin2ClientOffer rtcOffer = 6;
  bool has_rtcoffer() const;
  void clear_rtcoffer();
  static const int kRtcOfferFieldNumber = 6;
  private:
  const ::RTCAdmin2ClientOffer& _internal_rtcoffer() const;
  public:
  const ::RTCAdmin2ClientOffer& rtcoffer() const;
  ::RTCAdmin2ClientOffer* release_rtcoffer();
  ::RTCAdmin2ClientOffer* mutable_rtcoffer();
  void set_allocated_rtcoffer(::RTCAdmin2ClientOffer* rtcoffer);

  // .RTCClient2AdminAnswer rtcAnswer = 7;
  bool has_rtcanswer() const;
  void clear_rtcanswer();
  static const int kRtcAnswerFieldNumber = 7;
  private:
  const ::RTCClient2AdminAnswer& _internal_rtcanswer() const;
  public:
  const ::RTCClient2AdminAnswer& rtcanswer() const;
  ::RTCClient2AdminAnswer* release_rtcanswer();
  ::RTCClient2AdminAnswer* mutable_rtcanswer();
  void set_allocated_rtcanswer(::RTCClient2AdminAnswer* rtcanswer);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:ListenerToClientWrappedMessage)
 private:
  void set_has_invitationtoplay();
  void set_has_states();
  void set_has_invitationtoview();
  void set_has_rtcstates();
  void set_has_rtcrefuse();
  void set_has_rtcoffer();
  void set_has_rtcanswer();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::InvitationToPlayGame* invitationtoplay_;
    ::ListenerToClientGamesStates* states_;
    ::InvitationToViewGame* invitationtoview_;
    ::ListenerToClientsWebRTCGamesStates* rtcstates_;
    ::ListenerToClientsWebRTCRefuse* rtcrefuse_;
    ::RTCAdmin2ClientOffer* rtcoffer_;
    ::RTCClient2AdminAnswer* rtcanswer_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerWrappedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ServerWrappedMessage) */ {
 public:
  ServerWrappedMessage();
  virtual ~ServerWrappedMessage();

  ServerWrappedMessage(const ServerWrappedMessage& from);

  inline ServerWrappedMessage& operator=(const ServerWrappedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerWrappedMessage(ServerWrappedMessage&& from) noexcept
    : ServerWrappedMessage() {
    *this = ::std::move(from);
  }

  inline ServerWrappedMessage& operator=(ServerWrappedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerWrappedMessage& default_instance();

  enum MessageCase {
    kInvitationToPlay = 1,
    kInvitationToView = 2,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerWrappedMessage* internal_default_instance() {
    return reinterpret_cast<const ServerWrappedMessage*>(
               &_ServerWrappedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ServerWrappedMessage* other);
  friend void swap(ServerWrappedMessage& a, ServerWrappedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerWrappedMessage* New() const final {
    return CreateMaybeMessage<ServerWrappedMessage>(NULL);
  }

  ServerWrappedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerWrappedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerWrappedMessage& from);
  void MergeFrom(const ServerWrappedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerWrappedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .InvitationToPlayGame invitationToPlay = 1;
  bool has_invitationtoplay() const;
  void clear_invitationtoplay();
  static const int kInvitationToPlayFieldNumber = 1;
  private:
  const ::InvitationToPlayGame& _internal_invitationtoplay() const;
  public:
  const ::InvitationToPlayGame& invitationtoplay() const;
  ::InvitationToPlayGame* release_invitationtoplay();
  ::InvitationToPlayGame* mutable_invitationtoplay();
  void set_allocated_invitationtoplay(::InvitationToPlayGame* invitationtoplay);

  // .InvitationToViewGame invitationToView = 2;
  bool has_invitationtoview() const;
  void clear_invitationtoview();
  static const int kInvitationToViewFieldNumber = 2;
  private:
  const ::InvitationToViewGame& _internal_invitationtoview() const;
  public:
  const ::InvitationToViewGame& invitationtoview() const;
  ::InvitationToViewGame* release_invitationtoview();
  ::InvitationToViewGame* mutable_invitationtoview();
  void set_allocated_invitationtoview(::InvitationToViewGame* invitationtoview);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:ServerWrappedMessage)
 private:
  void set_has_invitationtoplay();
  void set_has_invitationtoview();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::InvitationToPlayGame* invitationtoplay_;
    ::InvitationToViewGame* invitationtoview_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyboardKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyboardKey) */ {
 public:
  KeyboardKey();
  virtual ~KeyboardKey();

  KeyboardKey(const KeyboardKey& from);

  inline KeyboardKey& operator=(const KeyboardKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyboardKey(KeyboardKey&& from) noexcept
    : KeyboardKey() {
    *this = ::std::move(from);
  }

  inline KeyboardKey& operator=(KeyboardKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyboardKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyboardKey* internal_default_instance() {
    return reinterpret_cast<const KeyboardKey*>(
               &_KeyboardKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(KeyboardKey* other);
  friend void swap(KeyboardKey& a, KeyboardKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyboardKey* New() const final {
    return CreateMaybeMessage<KeyboardKey>(NULL);
  }

  KeyboardKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyboardKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyboardKey& from);
  void MergeFrom(const KeyboardKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyboardKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 keyboardKey = 1;
  void clear_keyboardkey();
  static const int kKeyboardKeyFieldNumber = 1;
  ::google::protobuf::int32 keyboardkey() const;
  void set_keyboardkey(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:KeyboardKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 keyboardkey_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Ping) */ {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(Ping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(Ping* other);
  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ping* New() const final {
    return CreateMaybeMessage<Ping>(NULL);
  }

  Ping* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 ping = 1;
  void clear_ping();
  static const int kPingFieldNumber = 1;
  ::google::protobuf::int32 ping() const;
  void set_ping(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Ping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ping_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetQulon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SetQulon) */ {
 public:
  SetQulon();
  virtual ~SetQulon();

  SetQulon(const SetQulon& from);

  inline SetQulon& operator=(const SetQulon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetQulon(SetQulon&& from) noexcept
    : SetQulon() {
    *this = ::std::move(from);
  }

  inline SetQulon& operator=(SetQulon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetQulon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetQulon* internal_default_instance() {
    return reinterpret_cast<const SetQulon*>(
               &_SetQulon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(SetQulon* other);
  friend void swap(SetQulon& a, SetQulon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetQulon* New() const final {
    return CreateMaybeMessage<SetQulon>(NULL);
  }

  SetQulon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetQulon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetQulon& from);
  void MergeFrom(const SetQulon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetQulon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float qulon = 1;
  void clear_qulon();
  static const int kQulonFieldNumber = 1;
  float qulon() const;
  void set_qulon(float value);

  // @@protoc_insertion_point(class_scope:SetQulon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float qulon_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetLightVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SetLightVelocity) */ {
 public:
  SetLightVelocity();
  virtual ~SetLightVelocity();

  SetLightVelocity(const SetLightVelocity& from);

  inline SetLightVelocity& operator=(const SetLightVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetLightVelocity(SetLightVelocity&& from) noexcept
    : SetLightVelocity() {
    *this = ::std::move(from);
  }

  inline SetLightVelocity& operator=(SetLightVelocity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLightVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLightVelocity* internal_default_instance() {
    return reinterpret_cast<const SetLightVelocity*>(
               &_SetLightVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(SetLightVelocity* other);
  friend void swap(SetLightVelocity& a, SetLightVelocity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetLightVelocity* New() const final {
    return CreateMaybeMessage<SetLightVelocity>(NULL);
  }

  SetLightVelocity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetLightVelocity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetLightVelocity& from);
  void MergeFrom(const SetLightVelocity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLightVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float lightVelocity = 1;
  void clear_lightvelocity();
  static const int kLightVelocityFieldNumber = 1;
  float lightvelocity() const;
  void set_lightvelocity(float value);

  // @@protoc_insertion_point(class_scope:SetLightVelocity)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float lightvelocity_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetMagneticCalculated : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SetMagneticCalculated) */ {
 public:
  SetMagneticCalculated();
  virtual ~SetMagneticCalculated();

  SetMagneticCalculated(const SetMagneticCalculated& from);

  inline SetMagneticCalculated& operator=(const SetMagneticCalculated& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetMagneticCalculated(SetMagneticCalculated&& from) noexcept
    : SetMagneticCalculated() {
    *this = ::std::move(from);
  }

  inline SetMagneticCalculated& operator=(SetMagneticCalculated&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetMagneticCalculated& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetMagneticCalculated* internal_default_instance() {
    return reinterpret_cast<const SetMagneticCalculated*>(
               &_SetMagneticCalculated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(SetMagneticCalculated* other);
  friend void swap(SetMagneticCalculated& a, SetMagneticCalculated& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetMagneticCalculated* New() const final {
    return CreateMaybeMessage<SetMagneticCalculated>(NULL);
  }

  SetMagneticCalculated* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetMagneticCalculated>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetMagneticCalculated& from);
  void MergeFrom(const SetMagneticCalculated& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetMagneticCalculated* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool magneticCalculated = 1;
  void clear_magneticcalculated();
  static const int kMagneticCalculatedFieldNumber = 1;
  bool magneticcalculated() const;
  void set_magneticcalculated(bool value);

  // @@protoc_insertion_point(class_scope:SetMagneticCalculated)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool magneticcalculated_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientWrappedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ClientWrappedMessage) */ {
 public:
  ClientWrappedMessage();
  virtual ~ClientWrappedMessage();

  ClientWrappedMessage(const ClientWrappedMessage& from);

  inline ClientWrappedMessage& operator=(const ClientWrappedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientWrappedMessage(ClientWrappedMessage&& from) noexcept
    : ClientWrappedMessage() {
    *this = ::std::move(from);
  }

  inline ClientWrappedMessage& operator=(ClientWrappedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientWrappedMessage& default_instance();

  enum MessageCase {
    kKey = 1,
    kPing = 2,
    kQulon = 3,
    kLightVelocity = 4,
    kMagneticCalculated = 5,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientWrappedMessage* internal_default_instance() {
    return reinterpret_cast<const ClientWrappedMessage*>(
               &_ClientWrappedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(ClientWrappedMessage* other);
  friend void swap(ClientWrappedMessage& a, ClientWrappedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientWrappedMessage* New() const final {
    return CreateMaybeMessage<ClientWrappedMessage>(NULL);
  }

  ClientWrappedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientWrappedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientWrappedMessage& from);
  void MergeFrom(const ClientWrappedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientWrappedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .KeyboardKey key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::KeyboardKey& _internal_key() const;
  public:
  const ::KeyboardKey& key() const;
  ::KeyboardKey* release_key();
  ::KeyboardKey* mutable_key();
  void set_allocated_key(::KeyboardKey* key);

  // .Ping ping = 2;
  bool has_ping() const;
  void clear_ping();
  static const int kPingFieldNumber = 2;
  private:
  const ::Ping& _internal_ping() const;
  public:
  const ::Ping& ping() const;
  ::Ping* release_ping();
  ::Ping* mutable_ping();
  void set_allocated_ping(::Ping* ping);

  // .SetQulon qulon = 3;
  bool has_qulon() const;
  void clear_qulon();
  static const int kQulonFieldNumber = 3;
  private:
  const ::SetQulon& _internal_qulon() const;
  public:
  const ::SetQulon& qulon() const;
  ::SetQulon* release_qulon();
  ::SetQulon* mutable_qulon();
  void set_allocated_qulon(::SetQulon* qulon);

  // .SetLightVelocity lightVelocity = 4;
  bool has_lightvelocity() const;
  void clear_lightvelocity();
  static const int kLightVelocityFieldNumber = 4;
  private:
  const ::SetLightVelocity& _internal_lightvelocity() const;
  public:
  const ::SetLightVelocity& lightvelocity() const;
  ::SetLightVelocity* release_lightvelocity();
  ::SetLightVelocity* mutable_lightvelocity();
  void set_allocated_lightvelocity(::SetLightVelocity* lightvelocity);

  // .SetMagneticCalculated magneticCalculated = 5;
  bool has_magneticcalculated() const;
  void clear_magneticcalculated();
  static const int kMagneticCalculatedFieldNumber = 5;
  private:
  const ::SetMagneticCalculated& _internal_magneticcalculated() const;
  public:
  const ::SetMagneticCalculated& magneticcalculated() const;
  ::SetMagneticCalculated* release_magneticcalculated();
  ::SetMagneticCalculated* mutable_magneticcalculated();
  void set_allocated_magneticcalculated(::SetMagneticCalculated* magneticcalculated);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:ClientWrappedMessage)
 private:
  void set_has_key();
  void set_has_ping();
  void set_has_qulon();
  void set_has_lightvelocity();
  void set_has_magneticcalculated();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union MessageUnion {
    MessageUnion() {}
    ::KeyboardKey* key_;
    ::Ping* ping_;
    ::SetQulon* qulon_;
    ::SetLightVelocity* lightvelocity_;
    ::SetMagneticCalculated* magneticcalculated_;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_client_5flistener_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RoomInfo

// string roomName = 1;
inline void RoomInfo::clear_roomname() {
  roomname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RoomInfo::roomname() const {
  // @@protoc_insertion_point(field_get:RoomInfo.roomName)
  return roomname_.GetNoArena();
}
inline void RoomInfo::set_roomname(const ::std::string& value) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RoomInfo.roomName)
}
#if LANG_CXX11
inline void RoomInfo::set_roomname(::std::string&& value) {
  
  roomname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RoomInfo.roomName)
}
#endif
inline void RoomInfo::set_roomname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RoomInfo.roomName)
}
inline void RoomInfo::set_roomname(const char* value, size_t size) {
  
  roomname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RoomInfo.roomName)
}
inline ::std::string* RoomInfo::mutable_roomname() {
  
  // @@protoc_insertion_point(field_mutable:RoomInfo.roomName)
  return roomname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomInfo::release_roomname() {
  // @@protoc_insertion_point(field_release:RoomInfo.roomName)
  
  return roomname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomInfo::set_allocated_roomname(::std::string* roomname) {
  if (roomname != NULL) {
    
  } else {
    
  }
  roomname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomname);
  // @@protoc_insertion_point(field_set_allocated:RoomInfo.roomName)
}

// .RoomInfo.GameStatusEnum gameStatus = 2;
inline void RoomInfo::clear_gamestatus() {
  gamestatus_ = 0;
}
inline ::RoomInfo_GameStatusEnum RoomInfo::gamestatus() const {
  // @@protoc_insertion_point(field_get:RoomInfo.gameStatus)
  return static_cast< ::RoomInfo_GameStatusEnum >(gamestatus_);
}
inline void RoomInfo::set_gamestatus(::RoomInfo_GameStatusEnum value) {
  
  gamestatus_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.gameStatus)
}

// int32 roomSize = 3;
inline void RoomInfo::clear_roomsize() {
  roomsize_ = 0;
}
inline ::google::protobuf::int32 RoomInfo::roomsize() const {
  // @@protoc_insertion_point(field_get:RoomInfo.roomSize)
  return roomsize_;
}
inline void RoomInfo::set_roomsize(::google::protobuf::int32 value) {
  
  roomsize_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.roomSize)
}

// int32 waitingSize = 4;
inline void RoomInfo::clear_waitingsize() {
  waitingsize_ = 0;
}
inline ::google::protobuf::int32 RoomInfo::waitingsize() const {
  // @@protoc_insertion_point(field_get:RoomInfo.waitingSize)
  return waitingsize_;
}
inline void RoomInfo::set_waitingsize(::google::protobuf::int32 value) {
  
  waitingsize_ = value;
  // @@protoc_insertion_point(field_set:RoomInfo.waitingSize)
}

// -------------------------------------------------------------------

// ResponceOnGameInvitation

// bool responce = 1;
inline void ResponceOnGameInvitation::clear_responce() {
  responce_ = false;
}
inline bool ResponceOnGameInvitation::responce() const {
  // @@protoc_insertion_point(field_get:ResponceOnGameInvitation.responce)
  return responce_;
}
inline void ResponceOnGameInvitation::set_responce(bool value) {
  
  responce_ = value;
  // @@protoc_insertion_point(field_set:ResponceOnGameInvitation.responce)
}

// int32 ticket = 2;
inline void ResponceOnGameInvitation::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 ResponceOnGameInvitation::ticket() const {
  // @@protoc_insertion_point(field_get:ResponceOnGameInvitation.ticket)
  return ticket_;
}
inline void ResponceOnGameInvitation::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:ResponceOnGameInvitation.ticket)
}

// string clientIp = 3;
inline void ResponceOnGameInvitation::clear_clientip() {
  clientip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponceOnGameInvitation::clientip() const {
  // @@protoc_insertion_point(field_get:ResponceOnGameInvitation.clientIp)
  return clientip_.GetNoArena();
}
inline void ResponceOnGameInvitation::set_clientip(const ::std::string& value) {
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ResponceOnGameInvitation.clientIp)
}
#if LANG_CXX11
inline void ResponceOnGameInvitation::set_clientip(::std::string&& value) {
  
  clientip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ResponceOnGameInvitation.clientIp)
}
#endif
inline void ResponceOnGameInvitation::set_clientip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ResponceOnGameInvitation.clientIp)
}
inline void ResponceOnGameInvitation::set_clientip(const char* value, size_t size) {
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ResponceOnGameInvitation.clientIp)
}
inline ::std::string* ResponceOnGameInvitation::mutable_clientip() {
  
  // @@protoc_insertion_point(field_mutable:ResponceOnGameInvitation.clientIp)
  return clientip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponceOnGameInvitation::release_clientip() {
  // @@protoc_insertion_point(field_release:ResponceOnGameInvitation.clientIp)
  
  return clientip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponceOnGameInvitation::set_allocated_clientip(::std::string* clientip) {
  if (clientip != NULL) {
    
  } else {
    
  }
  clientip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientip);
  // @@protoc_insertion_point(field_set_allocated:ResponceOnGameInvitation.clientIp)
}

// int32 clientPort = 4;
inline void ResponceOnGameInvitation::clear_clientport() {
  clientport_ = 0;
}
inline ::google::protobuf::int32 ResponceOnGameInvitation::clientport() const {
  // @@protoc_insertion_point(field_get:ResponceOnGameInvitation.clientPort)
  return clientport_;
}
inline void ResponceOnGameInvitation::set_clientport(::google::protobuf::int32 value) {
  
  clientport_ = value;
  // @@protoc_insertion_point(field_set:ResponceOnGameInvitation.clientPort)
}

// -------------------------------------------------------------------

// ResponceOnGameView

// bool responce = 1;
inline void ResponceOnGameView::clear_responce() {
  responce_ = false;
}
inline bool ResponceOnGameView::responce() const {
  // @@protoc_insertion_point(field_get:ResponceOnGameView.responce)
  return responce_;
}
inline void ResponceOnGameView::set_responce(bool value) {
  
  responce_ = value;
  // @@protoc_insertion_point(field_set:ResponceOnGameView.responce)
}

// int32 ticket = 2;
inline void ResponceOnGameView::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 ResponceOnGameView::ticket() const {
  // @@protoc_insertion_point(field_get:ResponceOnGameView.ticket)
  return ticket_;
}
inline void ResponceOnGameView::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:ResponceOnGameView.ticket)
}

// string clientIp = 3;
inline void ResponceOnGameView::clear_clientip() {
  clientip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponceOnGameView::clientip() const {
  // @@protoc_insertion_point(field_get:ResponceOnGameView.clientIp)
  return clientip_.GetNoArena();
}
inline void ResponceOnGameView::set_clientip(const ::std::string& value) {
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ResponceOnGameView.clientIp)
}
#if LANG_CXX11
inline void ResponceOnGameView::set_clientip(::std::string&& value) {
  
  clientip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ResponceOnGameView.clientIp)
}
#endif
inline void ResponceOnGameView::set_clientip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ResponceOnGameView.clientIp)
}
inline void ResponceOnGameView::set_clientip(const char* value, size_t size) {
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ResponceOnGameView.clientIp)
}
inline ::std::string* ResponceOnGameView::mutable_clientip() {
  
  // @@protoc_insertion_point(field_mutable:ResponceOnGameView.clientIp)
  return clientip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponceOnGameView::release_clientip() {
  // @@protoc_insertion_point(field_release:ResponceOnGameView.clientIp)
  
  return clientip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponceOnGameView::set_allocated_clientip(::std::string* clientip) {
  if (clientip != NULL) {
    
  } else {
    
  }
  clientip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientip);
  // @@protoc_insertion_point(field_set_allocated:ResponceOnGameView.clientIp)
}

// int32 clientPort = 4;
inline void ResponceOnGameView::clear_clientport() {
  clientport_ = 0;
}
inline ::google::protobuf::int32 ResponceOnGameView::clientport() const {
  // @@protoc_insertion_point(field_get:ResponceOnGameView.clientPort)
  return clientport_;
}
inline void ResponceOnGameView::set_clientport(::google::protobuf::int32 value) {
  
  clientport_ = value;
  // @@protoc_insertion_point(field_set:ResponceOnGameView.clientPort)
}

// -------------------------------------------------------------------

// StartGame

// int32 ticket = 1;
inline void StartGame::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 StartGame::ticket() const {
  // @@protoc_insertion_point(field_get:StartGame.ticket)
  return ticket_;
}
inline void StartGame::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:StartGame.ticket)
}

// -------------------------------------------------------------------

// OneChargeInfo

// int32 id = 1;
inline void OneChargeInfo::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 OneChargeInfo::id() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.id)
  return id_;
}
inline void OneChargeInfo::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.id)
}

// .OneChargeInfo.Charge2DType type = 2;
inline void OneChargeInfo::clear_type() {
  type_ = 0;
}
inline ::OneChargeInfo_Charge2DType OneChargeInfo::type() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.type)
  return static_cast< ::OneChargeInfo_Charge2DType >(type_);
}
inline void OneChargeInfo::set_type(::OneChargeInfo_Charge2DType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.type)
}

// float m = 3;
inline void OneChargeInfo::clear_m() {
  m_ = 0;
}
inline float OneChargeInfo::m() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.m)
  return m_;
}
inline void OneChargeInfo::set_m(float value) {
  
  m_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.m)
}

// float charge = 4;
inline void OneChargeInfo::clear_charge() {
  charge_ = 0;
}
inline float OneChargeInfo::charge() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.charge)
  return charge_;
}
inline void OneChargeInfo::set_charge(float value) {
  
  charge_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.charge)
}

// float x = 5;
inline void OneChargeInfo::clear_x() {
  x_ = 0;
}
inline float OneChargeInfo::x() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.x)
  return x_;
}
inline void OneChargeInfo::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.x)
}

// float y = 6;
inline void OneChargeInfo::clear_y() {
  y_ = 0;
}
inline float OneChargeInfo::y() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.y)
  return y_;
}
inline void OneChargeInfo::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.y)
}

// float vx = 7;
inline void OneChargeInfo::clear_vx() {
  vx_ = 0;
}
inline float OneChargeInfo::vx() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.vx)
  return vx_;
}
inline void OneChargeInfo::set_vx(float value) {
  
  vx_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.vx)
}

// float vy = 8;
inline void OneChargeInfo::clear_vy() {
  vy_ = 0;
}
inline float OneChargeInfo::vy() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.vy)
  return vy_;
}
inline void OneChargeInfo::set_vy(float value) {
  
  vy_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.vy)
}

// float fex = 9;
inline void OneChargeInfo::clear_fex() {
  fex_ = 0;
}
inline float OneChargeInfo::fex() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.fex)
  return fex_;
}
inline void OneChargeInfo::set_fex(float value) {
  
  fex_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.fex)
}

// float fey = 10;
inline void OneChargeInfo::clear_fey() {
  fey_ = 0;
}
inline float OneChargeInfo::fey() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.fey)
  return fey_;
}
inline void OneChargeInfo::set_fey(float value) {
  
  fey_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.fey)
}

// float fbx = 11;
inline void OneChargeInfo::clear_fbx() {
  fbx_ = 0;
}
inline float OneChargeInfo::fbx() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.fbx)
  return fbx_;
}
inline void OneChargeInfo::set_fbx(float value) {
  
  fbx_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.fbx)
}

// float fby = 12;
inline void OneChargeInfo::clear_fby() {
  fby_ = 0;
}
inline float OneChargeInfo::fby() const {
  // @@protoc_insertion_point(field_get:OneChargeInfo.fby)
  return fby_;
}
inline void OneChargeInfo::set_fby(float value) {
  
  fby_ = value;
  // @@protoc_insertion_point(field_set:OneChargeInfo.fby)
}

// -------------------------------------------------------------------

// ShowStruct

// .ShowPaletteType paletteType = 1;
inline void ShowStruct::clear_palettetype() {
  palettetype_ = 0;
}
inline ::ShowPaletteType ShowStruct::palettetype() const {
  // @@protoc_insertion_point(field_get:ShowStruct.paletteType)
  return static_cast< ::ShowPaletteType >(palettetype_);
}
inline void ShowStruct::set_palettetype(::ShowPaletteType value) {
  
  palettetype_ = value;
  // @@protoc_insertion_point(field_set:ShowStruct.paletteType)
}

// string paletteName = 2;
inline void ShowStruct::clear_palettename() {
  palettename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ShowStruct::palettename() const {
  // @@protoc_insertion_point(field_get:ShowStruct.paletteName)
  return palettename_.GetNoArena();
}
inline void ShowStruct::set_palettename(const ::std::string& value) {
  
  palettename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShowStruct.paletteName)
}
#if LANG_CXX11
inline void ShowStruct::set_palettename(::std::string&& value) {
  
  palettename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShowStruct.paletteName)
}
#endif
inline void ShowStruct::set_palettename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  palettename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShowStruct.paletteName)
}
inline void ShowStruct::set_palettename(const char* value, size_t size) {
  
  palettename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShowStruct.paletteName)
}
inline ::std::string* ShowStruct::mutable_palettename() {
  
  // @@protoc_insertion_point(field_mutable:ShowStruct.paletteName)
  return palettename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShowStruct::release_palettename() {
  // @@protoc_insertion_point(field_release:ShowStruct.paletteName)
  
  return palettename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShowStruct::set_allocated_palettename(::std::string* palettename) {
  if (palettename != NULL) {
    
  } else {
    
  }
  palettename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), palettename);
  // @@protoc_insertion_point(field_set_allocated:ShowStruct.paletteName)
}

// -------------------------------------------------------------------

// SceneGeometry

// float width = 1;
inline void SceneGeometry::clear_width() {
  width_ = 0;
}
inline float SceneGeometry::width() const {
  // @@protoc_insertion_point(field_get:SceneGeometry.width)
  return width_;
}
inline void SceneGeometry::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:SceneGeometry.width)
}

// float height = 2;
inline void SceneGeometry::clear_height() {
  height_ = 0;
}
inline float SceneGeometry::height() const {
  // @@protoc_insertion_point(field_get:SceneGeometry.height)
  return height_;
}
inline void SceneGeometry::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:SceneGeometry.height)
}

// float qulon = 3;
inline void SceneGeometry::clear_qulon() {
  qulon_ = 0;
}
inline float SceneGeometry::qulon() const {
  // @@protoc_insertion_point(field_get:SceneGeometry.qulon)
  return qulon_;
}
inline void SceneGeometry::set_qulon(float value) {
  
  qulon_ = value;
  // @@protoc_insertion_point(field_set:SceneGeometry.qulon)
}

// float lightVelocity = 4;
inline void SceneGeometry::clear_lightvelocity() {
  lightvelocity_ = 0;
}
inline float SceneGeometry::lightvelocity() const {
  // @@protoc_insertion_point(field_get:SceneGeometry.lightVelocity)
  return lightvelocity_;
}
inline void SceneGeometry::set_lightvelocity(float value) {
  
  lightvelocity_ = value;
  // @@protoc_insertion_point(field_set:SceneGeometry.lightVelocity)
}

// bool ifMagnetic = 5;
inline void SceneGeometry::clear_ifmagnetic() {
  ifmagnetic_ = false;
}
inline bool SceneGeometry::ifmagnetic() const {
  // @@protoc_insertion_point(field_get:SceneGeometry.ifMagnetic)
  return ifmagnetic_;
}
inline void SceneGeometry::set_ifmagnetic(bool value) {
  
  ifmagnetic_ = value;
  // @@protoc_insertion_point(field_set:SceneGeometry.ifMagnetic)
}

// .ShowStruct forcesShowStruct = 6;
inline bool SceneGeometry::has_forcesshowstruct() const {
  return this != internal_default_instance() && forcesshowstruct_ != NULL;
}
inline void SceneGeometry::clear_forcesshowstruct() {
  if (GetArenaNoVirtual() == NULL && forcesshowstruct_ != NULL) {
    delete forcesshowstruct_;
  }
  forcesshowstruct_ = NULL;
}
inline const ::ShowStruct& SceneGeometry::_internal_forcesshowstruct() const {
  return *forcesshowstruct_;
}
inline const ::ShowStruct& SceneGeometry::forcesshowstruct() const {
  const ::ShowStruct* p = forcesshowstruct_;
  // @@protoc_insertion_point(field_get:SceneGeometry.forcesShowStruct)
  return p != NULL ? *p : *reinterpret_cast<const ::ShowStruct*>(
      &::_ShowStruct_default_instance_);
}
inline ::ShowStruct* SceneGeometry::release_forcesshowstruct() {
  // @@protoc_insertion_point(field_release:SceneGeometry.forcesShowStruct)
  
  ::ShowStruct* temp = forcesshowstruct_;
  forcesshowstruct_ = NULL;
  return temp;
}
inline ::ShowStruct* SceneGeometry::mutable_forcesshowstruct() {
  
  if (forcesshowstruct_ == NULL) {
    auto* p = CreateMaybeMessage<::ShowStruct>(GetArenaNoVirtual());
    forcesshowstruct_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SceneGeometry.forcesShowStruct)
  return forcesshowstruct_;
}
inline void SceneGeometry::set_allocated_forcesshowstruct(::ShowStruct* forcesshowstruct) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete forcesshowstruct_;
  }
  if (forcesshowstruct) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      forcesshowstruct = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, forcesshowstruct, submessage_arena);
    }
    
  } else {
    
  }
  forcesshowstruct_ = forcesshowstruct;
  // @@protoc_insertion_point(field_set_allocated:SceneGeometry.forcesShowStruct)
}

// .ShowStruct eqPotentialsShowStruct = 7;
inline bool SceneGeometry::has_eqpotentialsshowstruct() const {
  return this != internal_default_instance() && eqpotentialsshowstruct_ != NULL;
}
inline void SceneGeometry::clear_eqpotentialsshowstruct() {
  if (GetArenaNoVirtual() == NULL && eqpotentialsshowstruct_ != NULL) {
    delete eqpotentialsshowstruct_;
  }
  eqpotentialsshowstruct_ = NULL;
}
inline const ::ShowStruct& SceneGeometry::_internal_eqpotentialsshowstruct() const {
  return *eqpotentialsshowstruct_;
}
inline const ::ShowStruct& SceneGeometry::eqpotentialsshowstruct() const {
  const ::ShowStruct* p = eqpotentialsshowstruct_;
  // @@protoc_insertion_point(field_get:SceneGeometry.eqPotentialsShowStruct)
  return p != NULL ? *p : *reinterpret_cast<const ::ShowStruct*>(
      &::_ShowStruct_default_instance_);
}
inline ::ShowStruct* SceneGeometry::release_eqpotentialsshowstruct() {
  // @@protoc_insertion_point(field_release:SceneGeometry.eqPotentialsShowStruct)
  
  ::ShowStruct* temp = eqpotentialsshowstruct_;
  eqpotentialsshowstruct_ = NULL;
  return temp;
}
inline ::ShowStruct* SceneGeometry::mutable_eqpotentialsshowstruct() {
  
  if (eqpotentialsshowstruct_ == NULL) {
    auto* p = CreateMaybeMessage<::ShowStruct>(GetArenaNoVirtual());
    eqpotentialsshowstruct_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SceneGeometry.eqPotentialsShowStruct)
  return eqpotentialsshowstruct_;
}
inline void SceneGeometry::set_allocated_eqpotentialsshowstruct(::ShowStruct* eqpotentialsshowstruct) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete eqpotentialsshowstruct_;
  }
  if (eqpotentialsshowstruct) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eqpotentialsshowstruct = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eqpotentialsshowstruct, submessage_arena);
    }
    
  } else {
    
  }
  eqpotentialsshowstruct_ = eqpotentialsshowstruct;
  // @@protoc_insertion_point(field_set_allocated:SceneGeometry.eqPotentialsShowStruct)
}

// -------------------------------------------------------------------

// RTCGameClientRequest

// int32 id = 1;
inline void RTCGameClientRequest::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 RTCGameClientRequest::id() const {
  // @@protoc_insertion_point(field_get:RTCGameClientRequest.id)
  return id_;
}
inline void RTCGameClientRequest::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:RTCGameClientRequest.id)
}

// -------------------------------------------------------------------

// RTCGameAdminRequest

// string gameName = 1;
inline void RTCGameAdminRequest::clear_gamename() {
  gamename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RTCGameAdminRequest::gamename() const {
  // @@protoc_insertion_point(field_get:RTCGameAdminRequest.gameName)
  return gamename_.GetNoArena();
}
inline void RTCGameAdminRequest::set_gamename(const ::std::string& value) {
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RTCGameAdminRequest.gameName)
}
#if LANG_CXX11
inline void RTCGameAdminRequest::set_gamename(::std::string&& value) {
  
  gamename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RTCGameAdminRequest.gameName)
}
#endif
inline void RTCGameAdminRequest::set_gamename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RTCGameAdminRequest.gameName)
}
inline void RTCGameAdminRequest::set_gamename(const char* value, size_t size) {
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RTCGameAdminRequest.gameName)
}
inline ::std::string* RTCGameAdminRequest::mutable_gamename() {
  
  // @@protoc_insertion_point(field_mutable:RTCGameAdminRequest.gameName)
  return gamename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RTCGameAdminRequest::release_gamename() {
  // @@protoc_insertion_point(field_release:RTCGameAdminRequest.gameName)
  
  return gamename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RTCGameAdminRequest::set_allocated_gamename(::std::string* gamename) {
  if (gamename != NULL) {
    
  } else {
    
  }
  gamename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamename);
  // @@protoc_insertion_point(field_set_allocated:RTCGameAdminRequest.gameName)
}

// int32 roomSize = 2;
inline void RTCGameAdminRequest::clear_roomsize() {
  roomsize_ = 0;
}
inline ::google::protobuf::int32 RTCGameAdminRequest::roomsize() const {
  // @@protoc_insertion_point(field_get:RTCGameAdminRequest.roomSize)
  return roomsize_;
}
inline void RTCGameAdminRequest::set_roomsize(::google::protobuf::int32 value) {
  
  roomsize_ = value;
  // @@protoc_insertion_point(field_set:RTCGameAdminRequest.roomSize)
}

// -------------------------------------------------------------------

// PlayGameRequest

// string ip = 1;
inline void PlayGameRequest::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayGameRequest::ip() const {
  // @@protoc_insertion_point(field_get:PlayGameRequest.ip)
  return ip_.GetNoArena();
}
inline void PlayGameRequest::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PlayGameRequest.ip)
}
#if LANG_CXX11
inline void PlayGameRequest::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PlayGameRequest.ip)
}
#endif
inline void PlayGameRequest::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PlayGameRequest.ip)
}
inline void PlayGameRequest::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PlayGameRequest.ip)
}
inline ::std::string* PlayGameRequest::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:PlayGameRequest.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayGameRequest::release_ip() {
  // @@protoc_insertion_point(field_release:PlayGameRequest.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayGameRequest::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:PlayGameRequest.ip)
}

// int32 port = 2;
inline void PlayGameRequest::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 PlayGameRequest::port() const {
  // @@protoc_insertion_point(field_get:PlayGameRequest.port)
  return port_;
}
inline void PlayGameRequest::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:PlayGameRequest.port)
}

// -------------------------------------------------------------------

// ViewGameRequest

// string ip = 1;
inline void ViewGameRequest::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ViewGameRequest::ip() const {
  // @@protoc_insertion_point(field_get:ViewGameRequest.ip)
  return ip_.GetNoArena();
}
inline void ViewGameRequest::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ViewGameRequest.ip)
}
#if LANG_CXX11
inline void ViewGameRequest::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ViewGameRequest.ip)
}
#endif
inline void ViewGameRequest::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ViewGameRequest.ip)
}
inline void ViewGameRequest::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ViewGameRequest.ip)
}
inline ::std::string* ViewGameRequest::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:ViewGameRequest.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ViewGameRequest::release_ip() {
  // @@protoc_insertion_point(field_release:ViewGameRequest.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ViewGameRequest::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:ViewGameRequest.ip)
}

// int32 port = 2;
inline void ViewGameRequest::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 ViewGameRequest::port() const {
  // @@protoc_insertion_point(field_get:ViewGameRequest.port)
  return port_;
}
inline void ViewGameRequest::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:ViewGameRequest.port)
}

// -------------------------------------------------------------------

// RTCAdmin2ClientOffer

// int32 gameRTCID = 1;
inline void RTCAdmin2ClientOffer::clear_gamertcid() {
  gamertcid_ = 0;
}
inline ::google::protobuf::int32 RTCAdmin2ClientOffer::gamertcid() const {
  // @@protoc_insertion_point(field_get:RTCAdmin2ClientOffer.gameRTCID)
  return gamertcid_;
}
inline void RTCAdmin2ClientOffer::set_gamertcid(::google::protobuf::int32 value) {
  
  gamertcid_ = value;
  // @@protoc_insertion_point(field_set:RTCAdmin2ClientOffer.gameRTCID)
}

// string offer = 2;
inline void RTCAdmin2ClientOffer::clear_offer() {
  offer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RTCAdmin2ClientOffer::offer() const {
  // @@protoc_insertion_point(field_get:RTCAdmin2ClientOffer.offer)
  return offer_.GetNoArena();
}
inline void RTCAdmin2ClientOffer::set_offer(const ::std::string& value) {
  
  offer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RTCAdmin2ClientOffer.offer)
}
#if LANG_CXX11
inline void RTCAdmin2ClientOffer::set_offer(::std::string&& value) {
  
  offer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RTCAdmin2ClientOffer.offer)
}
#endif
inline void RTCAdmin2ClientOffer::set_offer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  offer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RTCAdmin2ClientOffer.offer)
}
inline void RTCAdmin2ClientOffer::set_offer(const char* value, size_t size) {
  
  offer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RTCAdmin2ClientOffer.offer)
}
inline ::std::string* RTCAdmin2ClientOffer::mutable_offer() {
  
  // @@protoc_insertion_point(field_mutable:RTCAdmin2ClientOffer.offer)
  return offer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RTCAdmin2ClientOffer::release_offer() {
  // @@protoc_insertion_point(field_release:RTCAdmin2ClientOffer.offer)
  
  return offer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RTCAdmin2ClientOffer::set_allocated_offer(::std::string* offer) {
  if (offer != NULL) {
    
  } else {
    
  }
  offer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), offer);
  // @@protoc_insertion_point(field_set_allocated:RTCAdmin2ClientOffer.offer)
}

// -------------------------------------------------------------------

// RTCClient2AdminAnswer

// int32 gameRTCID = 1;
inline void RTCClient2AdminAnswer::clear_gamertcid() {
  gamertcid_ = 0;
}
inline ::google::protobuf::int32 RTCClient2AdminAnswer::gamertcid() const {
  // @@protoc_insertion_point(field_get:RTCClient2AdminAnswer.gameRTCID)
  return gamertcid_;
}
inline void RTCClient2AdminAnswer::set_gamertcid(::google::protobuf::int32 value) {
  
  gamertcid_ = value;
  // @@protoc_insertion_point(field_set:RTCClient2AdminAnswer.gameRTCID)
}

// string answer = 2;
inline void RTCClient2AdminAnswer::clear_answer() {
  answer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RTCClient2AdminAnswer::answer() const {
  // @@protoc_insertion_point(field_get:RTCClient2AdminAnswer.answer)
  return answer_.GetNoArena();
}
inline void RTCClient2AdminAnswer::set_answer(const ::std::string& value) {
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RTCClient2AdminAnswer.answer)
}
#if LANG_CXX11
inline void RTCClient2AdminAnswer::set_answer(::std::string&& value) {
  
  answer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RTCClient2AdminAnswer.answer)
}
#endif
inline void RTCClient2AdminAnswer::set_answer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RTCClient2AdminAnswer.answer)
}
inline void RTCClient2AdminAnswer::set_answer(const char* value, size_t size) {
  
  answer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RTCClient2AdminAnswer.answer)
}
inline ::std::string* RTCClient2AdminAnswer::mutable_answer() {
  
  // @@protoc_insertion_point(field_mutable:RTCClient2AdminAnswer.answer)
  return answer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RTCClient2AdminAnswer::release_answer() {
  // @@protoc_insertion_point(field_release:RTCClient2AdminAnswer.answer)
  
  return answer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RTCClient2AdminAnswer::set_allocated_answer(::std::string* answer) {
  if (answer != NULL) {
    
  } else {
    
  }
  answer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), answer);
  // @@protoc_insertion_point(field_set_allocated:RTCClient2AdminAnswer.answer)
}

// -------------------------------------------------------------------

// ClientQueryRequest

// .PlayGameRequest playRequest = 1;
inline bool ClientQueryRequest::has_playrequest() const {
  return message_case() == kPlayRequest;
}
inline void ClientQueryRequest::set_has_playrequest() {
  _oneof_case_[0] = kPlayRequest;
}
inline void ClientQueryRequest::clear_playrequest() {
  if (has_playrequest()) {
    delete message_.playrequest_;
    clear_has_message();
  }
}
inline const ::PlayGameRequest& ClientQueryRequest::_internal_playrequest() const {
  return *message_.playrequest_;
}
inline ::PlayGameRequest* ClientQueryRequest::release_playrequest() {
  // @@protoc_insertion_point(field_release:ClientQueryRequest.playRequest)
  if (has_playrequest()) {
    clear_has_message();
      ::PlayGameRequest* temp = message_.playrequest_;
    message_.playrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::PlayGameRequest& ClientQueryRequest::playrequest() const {
  // @@protoc_insertion_point(field_get:ClientQueryRequest.playRequest)
  return has_playrequest()
      ? *message_.playrequest_
      : *reinterpret_cast< ::PlayGameRequest*>(&::_PlayGameRequest_default_instance_);
}
inline ::PlayGameRequest* ClientQueryRequest::mutable_playrequest() {
  if (!has_playrequest()) {
    clear_message();
    set_has_playrequest();
    message_.playrequest_ = CreateMaybeMessage< ::PlayGameRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientQueryRequest.playRequest)
  return message_.playrequest_;
}

// .ViewGameRequest viewRequest = 2;
inline bool ClientQueryRequest::has_viewrequest() const {
  return message_case() == kViewRequest;
}
inline void ClientQueryRequest::set_has_viewrequest() {
  _oneof_case_[0] = kViewRequest;
}
inline void ClientQueryRequest::clear_viewrequest() {
  if (has_viewrequest()) {
    delete message_.viewrequest_;
    clear_has_message();
  }
}
inline const ::ViewGameRequest& ClientQueryRequest::_internal_viewrequest() const {
  return *message_.viewrequest_;
}
inline ::ViewGameRequest* ClientQueryRequest::release_viewrequest() {
  // @@protoc_insertion_point(field_release:ClientQueryRequest.viewRequest)
  if (has_viewrequest()) {
    clear_has_message();
      ::ViewGameRequest* temp = message_.viewrequest_;
    message_.viewrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ViewGameRequest& ClientQueryRequest::viewrequest() const {
  // @@protoc_insertion_point(field_get:ClientQueryRequest.viewRequest)
  return has_viewrequest()
      ? *message_.viewrequest_
      : *reinterpret_cast< ::ViewGameRequest*>(&::_ViewGameRequest_default_instance_);
}
inline ::ViewGameRequest* ClientQueryRequest::mutable_viewrequest() {
  if (!has_viewrequest()) {
    clear_message();
    set_has_viewrequest();
    message_.viewrequest_ = CreateMaybeMessage< ::ViewGameRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientQueryRequest.viewRequest)
  return message_.viewrequest_;
}

// .RTCGameAdminRequest rtcAdminRequest = 3;
inline bool ClientQueryRequest::has_rtcadminrequest() const {
  return message_case() == kRtcAdminRequest;
}
inline void ClientQueryRequest::set_has_rtcadminrequest() {
  _oneof_case_[0] = kRtcAdminRequest;
}
inline void ClientQueryRequest::clear_rtcadminrequest() {
  if (has_rtcadminrequest()) {
    delete message_.rtcadminrequest_;
    clear_has_message();
  }
}
inline const ::RTCGameAdminRequest& ClientQueryRequest::_internal_rtcadminrequest() const {
  return *message_.rtcadminrequest_;
}
inline ::RTCGameAdminRequest* ClientQueryRequest::release_rtcadminrequest() {
  // @@protoc_insertion_point(field_release:ClientQueryRequest.rtcAdminRequest)
  if (has_rtcadminrequest()) {
    clear_has_message();
      ::RTCGameAdminRequest* temp = message_.rtcadminrequest_;
    message_.rtcadminrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RTCGameAdminRequest& ClientQueryRequest::rtcadminrequest() const {
  // @@protoc_insertion_point(field_get:ClientQueryRequest.rtcAdminRequest)
  return has_rtcadminrequest()
      ? *message_.rtcadminrequest_
      : *reinterpret_cast< ::RTCGameAdminRequest*>(&::_RTCGameAdminRequest_default_instance_);
}
inline ::RTCGameAdminRequest* ClientQueryRequest::mutable_rtcadminrequest() {
  if (!has_rtcadminrequest()) {
    clear_message();
    set_has_rtcadminrequest();
    message_.rtcadminrequest_ = CreateMaybeMessage< ::RTCGameAdminRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientQueryRequest.rtcAdminRequest)
  return message_.rtcadminrequest_;
}

// .RTCGameClientRequest rtcClientRequest = 4;
inline bool ClientQueryRequest::has_rtcclientrequest() const {
  return message_case() == kRtcClientRequest;
}
inline void ClientQueryRequest::set_has_rtcclientrequest() {
  _oneof_case_[0] = kRtcClientRequest;
}
inline void ClientQueryRequest::clear_rtcclientrequest() {
  if (has_rtcclientrequest()) {
    delete message_.rtcclientrequest_;
    clear_has_message();
  }
}
inline const ::RTCGameClientRequest& ClientQueryRequest::_internal_rtcclientrequest() const {
  return *message_.rtcclientrequest_;
}
inline ::RTCGameClientRequest* ClientQueryRequest::release_rtcclientrequest() {
  // @@protoc_insertion_point(field_release:ClientQueryRequest.rtcClientRequest)
  if (has_rtcclientrequest()) {
    clear_has_message();
      ::RTCGameClientRequest* temp = message_.rtcclientrequest_;
    message_.rtcclientrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RTCGameClientRequest& ClientQueryRequest::rtcclientrequest() const {
  // @@protoc_insertion_point(field_get:ClientQueryRequest.rtcClientRequest)
  return has_rtcclientrequest()
      ? *message_.rtcclientrequest_
      : *reinterpret_cast< ::RTCGameClientRequest*>(&::_RTCGameClientRequest_default_instance_);
}
inline ::RTCGameClientRequest* ClientQueryRequest::mutable_rtcclientrequest() {
  if (!has_rtcclientrequest()) {
    clear_message();
    set_has_rtcclientrequest();
    message_.rtcclientrequest_ = CreateMaybeMessage< ::RTCGameClientRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientQueryRequest.rtcClientRequest)
  return message_.rtcclientrequest_;
}

// .RTCAdmin2ClientOffer rtcOffer = 5;
inline bool ClientQueryRequest::has_rtcoffer() const {
  return message_case() == kRtcOffer;
}
inline void ClientQueryRequest::set_has_rtcoffer() {
  _oneof_case_[0] = kRtcOffer;
}
inline void ClientQueryRequest::clear_rtcoffer() {
  if (has_rtcoffer()) {
    delete message_.rtcoffer_;
    clear_has_message();
  }
}
inline const ::RTCAdmin2ClientOffer& ClientQueryRequest::_internal_rtcoffer() const {
  return *message_.rtcoffer_;
}
inline ::RTCAdmin2ClientOffer* ClientQueryRequest::release_rtcoffer() {
  // @@protoc_insertion_point(field_release:ClientQueryRequest.rtcOffer)
  if (has_rtcoffer()) {
    clear_has_message();
      ::RTCAdmin2ClientOffer* temp = message_.rtcoffer_;
    message_.rtcoffer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RTCAdmin2ClientOffer& ClientQueryRequest::rtcoffer() const {
  // @@protoc_insertion_point(field_get:ClientQueryRequest.rtcOffer)
  return has_rtcoffer()
      ? *message_.rtcoffer_
      : *reinterpret_cast< ::RTCAdmin2ClientOffer*>(&::_RTCAdmin2ClientOffer_default_instance_);
}
inline ::RTCAdmin2ClientOffer* ClientQueryRequest::mutable_rtcoffer() {
  if (!has_rtcoffer()) {
    clear_message();
    set_has_rtcoffer();
    message_.rtcoffer_ = CreateMaybeMessage< ::RTCAdmin2ClientOffer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientQueryRequest.rtcOffer)
  return message_.rtcoffer_;
}

// .RTCClient2AdminAnswer rtcAnswer = 6;
inline bool ClientQueryRequest::has_rtcanswer() const {
  return message_case() == kRtcAnswer;
}
inline void ClientQueryRequest::set_has_rtcanswer() {
  _oneof_case_[0] = kRtcAnswer;
}
inline void ClientQueryRequest::clear_rtcanswer() {
  if (has_rtcanswer()) {
    delete message_.rtcanswer_;
    clear_has_message();
  }
}
inline const ::RTCClient2AdminAnswer& ClientQueryRequest::_internal_rtcanswer() const {
  return *message_.rtcanswer_;
}
inline ::RTCClient2AdminAnswer* ClientQueryRequest::release_rtcanswer() {
  // @@protoc_insertion_point(field_release:ClientQueryRequest.rtcAnswer)
  if (has_rtcanswer()) {
    clear_has_message();
      ::RTCClient2AdminAnswer* temp = message_.rtcanswer_;
    message_.rtcanswer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RTCClient2AdminAnswer& ClientQueryRequest::rtcanswer() const {
  // @@protoc_insertion_point(field_get:ClientQueryRequest.rtcAnswer)
  return has_rtcanswer()
      ? *message_.rtcanswer_
      : *reinterpret_cast< ::RTCClient2AdminAnswer*>(&::_RTCClient2AdminAnswer_default_instance_);
}
inline ::RTCClient2AdminAnswer* ClientQueryRequest::mutable_rtcanswer() {
  if (!has_rtcanswer()) {
    clear_message();
    set_has_rtcanswer();
    message_.rtcanswer_ = CreateMaybeMessage< ::RTCClient2AdminAnswer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientQueryRequest.rtcAnswer)
  return message_.rtcanswer_;
}

inline bool ClientQueryRequest::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ClientQueryRequest::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ClientQueryRequest::MessageCase ClientQueryRequest::message_case() const {
  return ClientQueryRequest::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoomToClient

// int32 packetId = 1;
inline void RoomToClient::clear_packetid() {
  packetid_ = 0;
}
inline ::google::protobuf::int32 RoomToClient::packetid() const {
  // @@protoc_insertion_point(field_get:RoomToClient.packetId)
  return packetid_;
}
inline void RoomToClient::set_packetid(::google::protobuf::int32 value) {
  
  packetid_ = value;
  // @@protoc_insertion_point(field_set:RoomToClient.packetId)
}

// repeated .OneChargeInfo chargeInfo = 2;
inline int RoomToClient::chargeinfo_size() const {
  return chargeinfo_.size();
}
inline void RoomToClient::clear_chargeinfo() {
  chargeinfo_.Clear();
}
inline ::OneChargeInfo* RoomToClient::mutable_chargeinfo(int index) {
  // @@protoc_insertion_point(field_mutable:RoomToClient.chargeInfo)
  return chargeinfo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::OneChargeInfo >*
RoomToClient::mutable_chargeinfo() {
  // @@protoc_insertion_point(field_mutable_list:RoomToClient.chargeInfo)
  return &chargeinfo_;
}
inline const ::OneChargeInfo& RoomToClient::chargeinfo(int index) const {
  // @@protoc_insertion_point(field_get:RoomToClient.chargeInfo)
  return chargeinfo_.Get(index);
}
inline ::OneChargeInfo* RoomToClient::add_chargeinfo() {
  // @@protoc_insertion_point(field_add:RoomToClient.chargeInfo)
  return chargeinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OneChargeInfo >&
RoomToClient::chargeinfo() const {
  // @@protoc_insertion_point(field_list:RoomToClient.chargeInfo)
  return chargeinfo_;
}

// -------------------------------------------------------------------

// GameState

// int32 roomPort = 1;
inline void GameState::clear_roomport() {
  roomport_ = 0;
}
inline ::google::protobuf::int32 GameState::roomport() const {
  // @@protoc_insertion_point(field_get:GameState.roomPort)
  return roomport_;
}
inline void GameState::set_roomport(::google::protobuf::int32 value) {
  
  roomport_ = value;
  // @@protoc_insertion_point(field_set:GameState.roomPort)
}

// .RoomInfo roomInfo = 2;
inline bool GameState::has_roominfo() const {
  return this != internal_default_instance() && roominfo_ != NULL;
}
inline void GameState::clear_roominfo() {
  if (GetArenaNoVirtual() == NULL && roominfo_ != NULL) {
    delete roominfo_;
  }
  roominfo_ = NULL;
}
inline const ::RoomInfo& GameState::_internal_roominfo() const {
  return *roominfo_;
}
inline const ::RoomInfo& GameState::roominfo() const {
  const ::RoomInfo* p = roominfo_;
  // @@protoc_insertion_point(field_get:GameState.roomInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::RoomInfo*>(
      &::_RoomInfo_default_instance_);
}
inline ::RoomInfo* GameState::release_roominfo() {
  // @@protoc_insertion_point(field_release:GameState.roomInfo)
  
  ::RoomInfo* temp = roominfo_;
  roominfo_ = NULL;
  return temp;
}
inline ::RoomInfo* GameState::mutable_roominfo() {
  
  if (roominfo_ == NULL) {
    auto* p = CreateMaybeMessage<::RoomInfo>(GetArenaNoVirtual());
    roominfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GameState.roomInfo)
  return roominfo_;
}
inline void GameState::set_allocated_roominfo(::RoomInfo* roominfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roominfo_;
  }
  if (roominfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roominfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roominfo, submessage_arena);
    }
    
  } else {
    
  }
  roominfo_ = roominfo;
  // @@protoc_insertion_point(field_set_allocated:GameState.roomInfo)
}

// -------------------------------------------------------------------

// GameInfo

// .SceneGeometry geometry = 1;
inline bool GameInfo::has_geometry() const {
  return this != internal_default_instance() && geometry_ != NULL;
}
inline void GameInfo::clear_geometry() {
  if (GetArenaNoVirtual() == NULL && geometry_ != NULL) {
    delete geometry_;
  }
  geometry_ = NULL;
}
inline const ::SceneGeometry& GameInfo::_internal_geometry() const {
  return *geometry_;
}
inline const ::SceneGeometry& GameInfo::geometry() const {
  const ::SceneGeometry* p = geometry_;
  // @@protoc_insertion_point(field_get:GameInfo.geometry)
  return p != NULL ? *p : *reinterpret_cast<const ::SceneGeometry*>(
      &::_SceneGeometry_default_instance_);
}
inline ::SceneGeometry* GameInfo::release_geometry() {
  // @@protoc_insertion_point(field_release:GameInfo.geometry)
  
  ::SceneGeometry* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline ::SceneGeometry* GameInfo::mutable_geometry() {
  
  if (geometry_ == NULL) {
    auto* p = CreateMaybeMessage<::SceneGeometry>(GetArenaNoVirtual());
    geometry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GameInfo.geometry)
  return geometry_;
}
inline void GameInfo::set_allocated_geometry(::SceneGeometry* geometry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geometry_;
  }
  if (geometry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geometry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    
  } else {
    
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:GameInfo.geometry)
}

// int32 currentChargeId = 2;
inline void GameInfo::clear_currentchargeid() {
  currentchargeid_ = 0;
}
inline ::google::protobuf::int32 GameInfo::currentchargeid() const {
  // @@protoc_insertion_point(field_get:GameInfo.currentChargeId)
  return currentchargeid_;
}
inline void GameInfo::set_currentchargeid(::google::protobuf::int32 value) {
  
  currentchargeid_ = value;
  // @@protoc_insertion_point(field_set:GameInfo.currentChargeId)
}

// -------------------------------------------------------------------

// RoomWrappedToClientMessage

// .RoomToClient roomToClient = 1;
inline bool RoomWrappedToClientMessage::has_roomtoclient() const {
  return message_case() == kRoomToClient;
}
inline void RoomWrappedToClientMessage::set_has_roomtoclient() {
  _oneof_case_[0] = kRoomToClient;
}
inline void RoomWrappedToClientMessage::clear_roomtoclient() {
  if (has_roomtoclient()) {
    delete message_.roomtoclient_;
    clear_has_message();
  }
}
inline const ::RoomToClient& RoomWrappedToClientMessage::_internal_roomtoclient() const {
  return *message_.roomtoclient_;
}
inline ::RoomToClient* RoomWrappedToClientMessage::release_roomtoclient() {
  // @@protoc_insertion_point(field_release:RoomWrappedToClientMessage.roomToClient)
  if (has_roomtoclient()) {
    clear_has_message();
      ::RoomToClient* temp = message_.roomtoclient_;
    message_.roomtoclient_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RoomToClient& RoomWrappedToClientMessage::roomtoclient() const {
  // @@protoc_insertion_point(field_get:RoomWrappedToClientMessage.roomToClient)
  return has_roomtoclient()
      ? *message_.roomtoclient_
      : *reinterpret_cast< ::RoomToClient*>(&::_RoomToClient_default_instance_);
}
inline ::RoomToClient* RoomWrappedToClientMessage::mutable_roomtoclient() {
  if (!has_roomtoclient()) {
    clear_message();
    set_has_roomtoclient();
    message_.roomtoclient_ = CreateMaybeMessage< ::RoomToClient >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:RoomWrappedToClientMessage.roomToClient)
  return message_.roomtoclient_;
}

// .GameInfo gameInfo = 2;
inline bool RoomWrappedToClientMessage::has_gameinfo() const {
  return message_case() == kGameInfo;
}
inline void RoomWrappedToClientMessage::set_has_gameinfo() {
  _oneof_case_[0] = kGameInfo;
}
inline void RoomWrappedToClientMessage::clear_gameinfo() {
  if (has_gameinfo()) {
    delete message_.gameinfo_;
    clear_has_message();
  }
}
inline const ::GameInfo& RoomWrappedToClientMessage::_internal_gameinfo() const {
  return *message_.gameinfo_;
}
inline ::GameInfo* RoomWrappedToClientMessage::release_gameinfo() {
  // @@protoc_insertion_point(field_release:RoomWrappedToClientMessage.gameInfo)
  if (has_gameinfo()) {
    clear_has_message();
      ::GameInfo* temp = message_.gameinfo_;
    message_.gameinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::GameInfo& RoomWrappedToClientMessage::gameinfo() const {
  // @@protoc_insertion_point(field_get:RoomWrappedToClientMessage.gameInfo)
  return has_gameinfo()
      ? *message_.gameinfo_
      : *reinterpret_cast< ::GameInfo*>(&::_GameInfo_default_instance_);
}
inline ::GameInfo* RoomWrappedToClientMessage::mutable_gameinfo() {
  if (!has_gameinfo()) {
    clear_message();
    set_has_gameinfo();
    message_.gameinfo_ = CreateMaybeMessage< ::GameInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:RoomWrappedToClientMessage.gameInfo)
  return message_.gameinfo_;
}

inline bool RoomWrappedToClientMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void RoomWrappedToClientMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline RoomWrappedToClientMessage::MessageCase RoomWrappedToClientMessage::message_case() const {
  return RoomWrappedToClientMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WebRTCGameInfo

// string url = 1;
inline void WebRTCGameInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WebRTCGameInfo::url() const {
  // @@protoc_insertion_point(field_get:WebRTCGameInfo.url)
  return url_.GetNoArena();
}
inline void WebRTCGameInfo::set_url(const ::std::string& value) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WebRTCGameInfo.url)
}
#if LANG_CXX11
inline void WebRTCGameInfo::set_url(::std::string&& value) {
  
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WebRTCGameInfo.url)
}
#endif
inline void WebRTCGameInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WebRTCGameInfo.url)
}
inline void WebRTCGameInfo::set_url(const char* value, size_t size) {
  
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WebRTCGameInfo.url)
}
inline ::std::string* WebRTCGameInfo::mutable_url() {
  
  // @@protoc_insertion_point(field_mutable:WebRTCGameInfo.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WebRTCGameInfo::release_url() {
  // @@protoc_insertion_point(field_release:WebRTCGameInfo.url)
  
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WebRTCGameInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    
  } else {
    
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:WebRTCGameInfo.url)
}

// int32 gameid = 2;
inline void WebRTCGameInfo::clear_gameid() {
  gameid_ = 0;
}
inline ::google::protobuf::int32 WebRTCGameInfo::gameid() const {
  // @@protoc_insertion_point(field_get:WebRTCGameInfo.gameid)
  return gameid_;
}
inline void WebRTCGameInfo::set_gameid(::google::protobuf::int32 value) {
  
  gameid_ = value;
  // @@protoc_insertion_point(field_set:WebRTCGameInfo.gameid)
}

// string forcePalette = 3;
inline void WebRTCGameInfo::clear_forcepalette() {
  forcepalette_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WebRTCGameInfo::forcepalette() const {
  // @@protoc_insertion_point(field_get:WebRTCGameInfo.forcePalette)
  return forcepalette_.GetNoArena();
}
inline void WebRTCGameInfo::set_forcepalette(const ::std::string& value) {
  
  forcepalette_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WebRTCGameInfo.forcePalette)
}
#if LANG_CXX11
inline void WebRTCGameInfo::set_forcepalette(::std::string&& value) {
  
  forcepalette_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WebRTCGameInfo.forcePalette)
}
#endif
inline void WebRTCGameInfo::set_forcepalette(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  forcepalette_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WebRTCGameInfo.forcePalette)
}
inline void WebRTCGameInfo::set_forcepalette(const char* value, size_t size) {
  
  forcepalette_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WebRTCGameInfo.forcePalette)
}
inline ::std::string* WebRTCGameInfo::mutable_forcepalette() {
  
  // @@protoc_insertion_point(field_mutable:WebRTCGameInfo.forcePalette)
  return forcepalette_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WebRTCGameInfo::release_forcepalette() {
  // @@protoc_insertion_point(field_release:WebRTCGameInfo.forcePalette)
  
  return forcepalette_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WebRTCGameInfo::set_allocated_forcepalette(::std::string* forcepalette) {
  if (forcepalette != NULL) {
    
  } else {
    
  }
  forcepalette_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), forcepalette);
  // @@protoc_insertion_point(field_set_allocated:WebRTCGameInfo.forcePalette)
}

// string eqPotPalette = 4;
inline void WebRTCGameInfo::clear_eqpotpalette() {
  eqpotpalette_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WebRTCGameInfo::eqpotpalette() const {
  // @@protoc_insertion_point(field_get:WebRTCGameInfo.eqPotPalette)
  return eqpotpalette_.GetNoArena();
}
inline void WebRTCGameInfo::set_eqpotpalette(const ::std::string& value) {
  
  eqpotpalette_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WebRTCGameInfo.eqPotPalette)
}
#if LANG_CXX11
inline void WebRTCGameInfo::set_eqpotpalette(::std::string&& value) {
  
  eqpotpalette_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WebRTCGameInfo.eqPotPalette)
}
#endif
inline void WebRTCGameInfo::set_eqpotpalette(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  eqpotpalette_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WebRTCGameInfo.eqPotPalette)
}
inline void WebRTCGameInfo::set_eqpotpalette(const char* value, size_t size) {
  
  eqpotpalette_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WebRTCGameInfo.eqPotPalette)
}
inline ::std::string* WebRTCGameInfo::mutable_eqpotpalette() {
  
  // @@protoc_insertion_point(field_mutable:WebRTCGameInfo.eqPotPalette)
  return eqpotpalette_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WebRTCGameInfo::release_eqpotpalette() {
  // @@protoc_insertion_point(field_release:WebRTCGameInfo.eqPotPalette)
  
  return eqpotpalette_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WebRTCGameInfo::set_allocated_eqpotpalette(::std::string* eqpotpalette) {
  if (eqpotpalette != NULL) {
    
  } else {
    
  }
  eqpotpalette_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), eqpotpalette);
  // @@protoc_insertion_point(field_set_allocated:WebRTCGameInfo.eqPotPalette)
}

// -------------------------------------------------------------------

// WebRTCAdminToClientMessage

// .WebRTCGameInfo rtcGameInfo = 1;
inline bool WebRTCAdminToClientMessage::has_rtcgameinfo() const {
  return message_case() == kRtcGameInfo;
}
inline void WebRTCAdminToClientMessage::set_has_rtcgameinfo() {
  _oneof_case_[0] = kRtcGameInfo;
}
inline void WebRTCAdminToClientMessage::clear_rtcgameinfo() {
  if (has_rtcgameinfo()) {
    delete message_.rtcgameinfo_;
    clear_has_message();
  }
}
inline const ::WebRTCGameInfo& WebRTCAdminToClientMessage::_internal_rtcgameinfo() const {
  return *message_.rtcgameinfo_;
}
inline ::WebRTCGameInfo* WebRTCAdminToClientMessage::release_rtcgameinfo() {
  // @@protoc_insertion_point(field_release:WebRTCAdminToClientMessage.rtcGameInfo)
  if (has_rtcgameinfo()) {
    clear_has_message();
      ::WebRTCGameInfo* temp = message_.rtcgameinfo_;
    message_.rtcgameinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::WebRTCGameInfo& WebRTCAdminToClientMessage::rtcgameinfo() const {
  // @@protoc_insertion_point(field_get:WebRTCAdminToClientMessage.rtcGameInfo)
  return has_rtcgameinfo()
      ? *message_.rtcgameinfo_
      : *reinterpret_cast< ::WebRTCGameInfo*>(&::_WebRTCGameInfo_default_instance_);
}
inline ::WebRTCGameInfo* WebRTCAdminToClientMessage::mutable_rtcgameinfo() {
  if (!has_rtcgameinfo()) {
    clear_message();
    set_has_rtcgameinfo();
    message_.rtcgameinfo_ = CreateMaybeMessage< ::WebRTCGameInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:WebRTCAdminToClientMessage.rtcGameInfo)
  return message_.rtcgameinfo_;
}

inline bool WebRTCAdminToClientMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void WebRTCAdminToClientMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline WebRTCAdminToClientMessage::MessageCase WebRTCAdminToClientMessage::message_case() const {
  return WebRTCAdminToClientMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoomWrappedMessage

// .RoomInfo roomInfo = 1;
inline bool RoomWrappedMessage::has_roominfo() const {
  return message_case() == kRoomInfo;
}
inline void RoomWrappedMessage::set_has_roominfo() {
  _oneof_case_[0] = kRoomInfo;
}
inline void RoomWrappedMessage::clear_roominfo() {
  if (has_roominfo()) {
    delete message_.roominfo_;
    clear_has_message();
  }
}
inline const ::RoomInfo& RoomWrappedMessage::_internal_roominfo() const {
  return *message_.roominfo_;
}
inline ::RoomInfo* RoomWrappedMessage::release_roominfo() {
  // @@protoc_insertion_point(field_release:RoomWrappedMessage.roomInfo)
  if (has_roominfo()) {
    clear_has_message();
      ::RoomInfo* temp = message_.roominfo_;
    message_.roominfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RoomInfo& RoomWrappedMessage::roominfo() const {
  // @@protoc_insertion_point(field_get:RoomWrappedMessage.roomInfo)
  return has_roominfo()
      ? *message_.roominfo_
      : *reinterpret_cast< ::RoomInfo*>(&::_RoomInfo_default_instance_);
}
inline ::RoomInfo* RoomWrappedMessage::mutable_roominfo() {
  if (!has_roominfo()) {
    clear_message();
    set_has_roominfo();
    message_.roominfo_ = CreateMaybeMessage< ::RoomInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:RoomWrappedMessage.roomInfo)
  return message_.roominfo_;
}

// .ResponceOnGameInvitation responceInvitation = 2;
inline bool RoomWrappedMessage::has_responceinvitation() const {
  return message_case() == kResponceInvitation;
}
inline void RoomWrappedMessage::set_has_responceinvitation() {
  _oneof_case_[0] = kResponceInvitation;
}
inline void RoomWrappedMessage::clear_responceinvitation() {
  if (has_responceinvitation()) {
    delete message_.responceinvitation_;
    clear_has_message();
  }
}
inline const ::ResponceOnGameInvitation& RoomWrappedMessage::_internal_responceinvitation() const {
  return *message_.responceinvitation_;
}
inline ::ResponceOnGameInvitation* RoomWrappedMessage::release_responceinvitation() {
  // @@protoc_insertion_point(field_release:RoomWrappedMessage.responceInvitation)
  if (has_responceinvitation()) {
    clear_has_message();
      ::ResponceOnGameInvitation* temp = message_.responceinvitation_;
    message_.responceinvitation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ResponceOnGameInvitation& RoomWrappedMessage::responceinvitation() const {
  // @@protoc_insertion_point(field_get:RoomWrappedMessage.responceInvitation)
  return has_responceinvitation()
      ? *message_.responceinvitation_
      : *reinterpret_cast< ::ResponceOnGameInvitation*>(&::_ResponceOnGameInvitation_default_instance_);
}
inline ::ResponceOnGameInvitation* RoomWrappedMessage::mutable_responceinvitation() {
  if (!has_responceinvitation()) {
    clear_message();
    set_has_responceinvitation();
    message_.responceinvitation_ = CreateMaybeMessage< ::ResponceOnGameInvitation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:RoomWrappedMessage.responceInvitation)
  return message_.responceinvitation_;
}

// .ResponceOnGameView responceView = 3;
inline bool RoomWrappedMessage::has_responceview() const {
  return message_case() == kResponceView;
}
inline void RoomWrappedMessage::set_has_responceview() {
  _oneof_case_[0] = kResponceView;
}
inline void RoomWrappedMessage::clear_responceview() {
  if (has_responceview()) {
    delete message_.responceview_;
    clear_has_message();
  }
}
inline const ::ResponceOnGameView& RoomWrappedMessage::_internal_responceview() const {
  return *message_.responceview_;
}
inline ::ResponceOnGameView* RoomWrappedMessage::release_responceview() {
  // @@protoc_insertion_point(field_release:RoomWrappedMessage.responceView)
  if (has_responceview()) {
    clear_has_message();
      ::ResponceOnGameView* temp = message_.responceview_;
    message_.responceview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ResponceOnGameView& RoomWrappedMessage::responceview() const {
  // @@protoc_insertion_point(field_get:RoomWrappedMessage.responceView)
  return has_responceview()
      ? *message_.responceview_
      : *reinterpret_cast< ::ResponceOnGameView*>(&::_ResponceOnGameView_default_instance_);
}
inline ::ResponceOnGameView* RoomWrappedMessage::mutable_responceview() {
  if (!has_responceview()) {
    clear_message();
    set_has_responceview();
    message_.responceview_ = CreateMaybeMessage< ::ResponceOnGameView >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:RoomWrappedMessage.responceView)
  return message_.responceview_;
}

// .StartGame startGame = 4;
inline bool RoomWrappedMessage::has_startgame() const {
  return message_case() == kStartGame;
}
inline void RoomWrappedMessage::set_has_startgame() {
  _oneof_case_[0] = kStartGame;
}
inline void RoomWrappedMessage::clear_startgame() {
  if (has_startgame()) {
    delete message_.startgame_;
    clear_has_message();
  }
}
inline const ::StartGame& RoomWrappedMessage::_internal_startgame() const {
  return *message_.startgame_;
}
inline ::StartGame* RoomWrappedMessage::release_startgame() {
  // @@protoc_insertion_point(field_release:RoomWrappedMessage.startGame)
  if (has_startgame()) {
    clear_has_message();
      ::StartGame* temp = message_.startgame_;
    message_.startgame_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::StartGame& RoomWrappedMessage::startgame() const {
  // @@protoc_insertion_point(field_get:RoomWrappedMessage.startGame)
  return has_startgame()
      ? *message_.startgame_
      : *reinterpret_cast< ::StartGame*>(&::_StartGame_default_instance_);
}
inline ::StartGame* RoomWrappedMessage::mutable_startgame() {
  if (!has_startgame()) {
    clear_message();
    set_has_startgame();
    message_.startgame_ = CreateMaybeMessage< ::StartGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:RoomWrappedMessage.startGame)
  return message_.startgame_;
}

inline bool RoomWrappedMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void RoomWrappedMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline RoomWrappedMessage::MessageCase RoomWrappedMessage::message_case() const {
  return RoomWrappedMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InvitationToPlayGame

// int32 clientPort = 1;
inline void InvitationToPlayGame::clear_clientport() {
  clientport_ = 0;
}
inline ::google::protobuf::int32 InvitationToPlayGame::clientport() const {
  // @@protoc_insertion_point(field_get:InvitationToPlayGame.clientPort)
  return clientport_;
}
inline void InvitationToPlayGame::set_clientport(::google::protobuf::int32 value) {
  
  clientport_ = value;
  // @@protoc_insertion_point(field_set:InvitationToPlayGame.clientPort)
}

// string clientIp = 2;
inline void InvitationToPlayGame::clear_clientip() {
  clientip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InvitationToPlayGame::clientip() const {
  // @@protoc_insertion_point(field_get:InvitationToPlayGame.clientIp)
  return clientip_.GetNoArena();
}
inline void InvitationToPlayGame::set_clientip(const ::std::string& value) {
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InvitationToPlayGame.clientIp)
}
#if LANG_CXX11
inline void InvitationToPlayGame::set_clientip(::std::string&& value) {
  
  clientip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InvitationToPlayGame.clientIp)
}
#endif
inline void InvitationToPlayGame::set_clientip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InvitationToPlayGame.clientIp)
}
inline void InvitationToPlayGame::set_clientip(const char* value, size_t size) {
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InvitationToPlayGame.clientIp)
}
inline ::std::string* InvitationToPlayGame::mutable_clientip() {
  
  // @@protoc_insertion_point(field_mutable:InvitationToPlayGame.clientIp)
  return clientip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InvitationToPlayGame::release_clientip() {
  // @@protoc_insertion_point(field_release:InvitationToPlayGame.clientIp)
  
  return clientip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InvitationToPlayGame::set_allocated_clientip(::std::string* clientip) {
  if (clientip != NULL) {
    
  } else {
    
  }
  clientip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientip);
  // @@protoc_insertion_point(field_set_allocated:InvitationToPlayGame.clientIp)
}

// int32 ticket = 3;
inline void InvitationToPlayGame::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 InvitationToPlayGame::ticket() const {
  // @@protoc_insertion_point(field_get:InvitationToPlayGame.ticket)
  return ticket_;
}
inline void InvitationToPlayGame::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:InvitationToPlayGame.ticket)
}

// -------------------------------------------------------------------

// InvitationToViewGame

// int32 clientPort = 1;
inline void InvitationToViewGame::clear_clientport() {
  clientport_ = 0;
}
inline ::google::protobuf::int32 InvitationToViewGame::clientport() const {
  // @@protoc_insertion_point(field_get:InvitationToViewGame.clientPort)
  return clientport_;
}
inline void InvitationToViewGame::set_clientport(::google::protobuf::int32 value) {
  
  clientport_ = value;
  // @@protoc_insertion_point(field_set:InvitationToViewGame.clientPort)
}

// string clientIp = 2;
inline void InvitationToViewGame::clear_clientip() {
  clientip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InvitationToViewGame::clientip() const {
  // @@protoc_insertion_point(field_get:InvitationToViewGame.clientIp)
  return clientip_.GetNoArena();
}
inline void InvitationToViewGame::set_clientip(const ::std::string& value) {
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:InvitationToViewGame.clientIp)
}
#if LANG_CXX11
inline void InvitationToViewGame::set_clientip(::std::string&& value) {
  
  clientip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:InvitationToViewGame.clientIp)
}
#endif
inline void InvitationToViewGame::set_clientip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:InvitationToViewGame.clientIp)
}
inline void InvitationToViewGame::set_clientip(const char* value, size_t size) {
  
  clientip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:InvitationToViewGame.clientIp)
}
inline ::std::string* InvitationToViewGame::mutable_clientip() {
  
  // @@protoc_insertion_point(field_mutable:InvitationToViewGame.clientIp)
  return clientip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InvitationToViewGame::release_clientip() {
  // @@protoc_insertion_point(field_release:InvitationToViewGame.clientIp)
  
  return clientip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InvitationToViewGame::set_allocated_clientip(::std::string* clientip) {
  if (clientip != NULL) {
    
  } else {
    
  }
  clientip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientip);
  // @@protoc_insertion_point(field_set_allocated:InvitationToViewGame.clientIp)
}

// int32 ticket = 3;
inline void InvitationToViewGame::clear_ticket() {
  ticket_ = 0;
}
inline ::google::protobuf::int32 InvitationToViewGame::ticket() const {
  // @@protoc_insertion_point(field_get:InvitationToViewGame.ticket)
  return ticket_;
}
inline void InvitationToViewGame::set_ticket(::google::protobuf::int32 value) {
  
  ticket_ = value;
  // @@protoc_insertion_point(field_set:InvitationToViewGame.ticket)
}

// -------------------------------------------------------------------

// ListenerToClientGamesStates

// repeated .GameState gameState = 1;
inline int ListenerToClientGamesStates::gamestate_size() const {
  return gamestate_.size();
}
inline void ListenerToClientGamesStates::clear_gamestate() {
  gamestate_.Clear();
}
inline ::GameState* ListenerToClientGamesStates::mutable_gamestate(int index) {
  // @@protoc_insertion_point(field_mutable:ListenerToClientGamesStates.gameState)
  return gamestate_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::GameState >*
ListenerToClientGamesStates::mutable_gamestate() {
  // @@protoc_insertion_point(field_mutable_list:ListenerToClientGamesStates.gameState)
  return &gamestate_;
}
inline const ::GameState& ListenerToClientGamesStates::gamestate(int index) const {
  // @@protoc_insertion_point(field_get:ListenerToClientGamesStates.gameState)
  return gamestate_.Get(index);
}
inline ::GameState* ListenerToClientGamesStates::add_gamestate() {
  // @@protoc_insertion_point(field_add:ListenerToClientGamesStates.gameState)
  return gamestate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameState >&
ListenerToClientGamesStates::gamestate() const {
  // @@protoc_insertion_point(field_list:ListenerToClientGamesStates.gameState)
  return gamestate_;
}

// -------------------------------------------------------------------

// rtcGameState

// int32 gameRTCID = 1;
inline void rtcGameState::clear_gamertcid() {
  gamertcid_ = 0;
}
inline ::google::protobuf::int32 rtcGameState::gamertcid() const {
  // @@protoc_insertion_point(field_get:rtcGameState.gameRTCID)
  return gamertcid_;
}
inline void rtcGameState::set_gamertcid(::google::protobuf::int32 value) {
  
  gamertcid_ = value;
  // @@protoc_insertion_point(field_set:rtcGameState.gameRTCID)
}

// string gameName = 2;
inline void rtcGameState::clear_gamename() {
  gamename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& rtcGameState::gamename() const {
  // @@protoc_insertion_point(field_get:rtcGameState.gameName)
  return gamename_.GetNoArena();
}
inline void rtcGameState::set_gamename(const ::std::string& value) {
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rtcGameState.gameName)
}
#if LANG_CXX11
inline void rtcGameState::set_gamename(::std::string&& value) {
  
  gamename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rtcGameState.gameName)
}
#endif
inline void rtcGameState::set_gamename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rtcGameState.gameName)
}
inline void rtcGameState::set_gamename(const char* value, size_t size) {
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rtcGameState.gameName)
}
inline ::std::string* rtcGameState::mutable_gamename() {
  
  // @@protoc_insertion_point(field_mutable:rtcGameState.gameName)
  return gamename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* rtcGameState::release_gamename() {
  // @@protoc_insertion_point(field_release:rtcGameState.gameName)
  
  return gamename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void rtcGameState::set_allocated_gamename(::std::string* gamename) {
  if (gamename != NULL) {
    
  } else {
    
  }
  gamename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamename);
  // @@protoc_insertion_point(field_set_allocated:rtcGameState.gameName)
}

// int32 roomSize = 3;
inline void rtcGameState::clear_roomsize() {
  roomsize_ = 0;
}
inline ::google::protobuf::int32 rtcGameState::roomsize() const {
  // @@protoc_insertion_point(field_get:rtcGameState.roomSize)
  return roomsize_;
}
inline void rtcGameState::set_roomsize(::google::protobuf::int32 value) {
  
  roomsize_ = value;
  // @@protoc_insertion_point(field_set:rtcGameState.roomSize)
}

// int32 currentPlayersCount = 4;
inline void rtcGameState::clear_currentplayerscount() {
  currentplayerscount_ = 0;
}
inline ::google::protobuf::int32 rtcGameState::currentplayerscount() const {
  // @@protoc_insertion_point(field_get:rtcGameState.currentPlayersCount)
  return currentplayerscount_;
}
inline void rtcGameState::set_currentplayerscount(::google::protobuf::int32 value) {
  
  currentplayerscount_ = value;
  // @@protoc_insertion_point(field_set:rtcGameState.currentPlayersCount)
}

// .WebRTCPlayerStatus playerStatus = 5;
inline void rtcGameState::clear_playerstatus() {
  playerstatus_ = 0;
}
inline ::WebRTCPlayerStatus rtcGameState::playerstatus() const {
  // @@protoc_insertion_point(field_get:rtcGameState.playerStatus)
  return static_cast< ::WebRTCPlayerStatus >(playerstatus_);
}
inline void rtcGameState::set_playerstatus(::WebRTCPlayerStatus value) {
  
  playerstatus_ = value;
  // @@protoc_insertion_point(field_set:rtcGameState.playerStatus)
}

// -------------------------------------------------------------------

// ListenerToClientsWebRTCGamesStates

// repeated .rtcGameState rtcState = 1;
inline int ListenerToClientsWebRTCGamesStates::rtcstate_size() const {
  return rtcstate_.size();
}
inline void ListenerToClientsWebRTCGamesStates::clear_rtcstate() {
  rtcstate_.Clear();
}
inline ::rtcGameState* ListenerToClientsWebRTCGamesStates::mutable_rtcstate(int index) {
  // @@protoc_insertion_point(field_mutable:ListenerToClientsWebRTCGamesStates.rtcState)
  return rtcstate_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::rtcGameState >*
ListenerToClientsWebRTCGamesStates::mutable_rtcstate() {
  // @@protoc_insertion_point(field_mutable_list:ListenerToClientsWebRTCGamesStates.rtcState)
  return &rtcstate_;
}
inline const ::rtcGameState& ListenerToClientsWebRTCGamesStates::rtcstate(int index) const {
  // @@protoc_insertion_point(field_get:ListenerToClientsWebRTCGamesStates.rtcState)
  return rtcstate_.Get(index);
}
inline ::rtcGameState* ListenerToClientsWebRTCGamesStates::add_rtcstate() {
  // @@protoc_insertion_point(field_add:ListenerToClientsWebRTCGamesStates.rtcState)
  return rtcstate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rtcGameState >&
ListenerToClientsWebRTCGamesStates::rtcstate() const {
  // @@protoc_insertion_point(field_list:ListenerToClientsWebRTCGamesStates.rtcState)
  return rtcstate_;
}

// -------------------------------------------------------------------

// ListenerToClientsWebRTCRefuse

// int32 gameRTCID = 1;
inline void ListenerToClientsWebRTCRefuse::clear_gamertcid() {
  gamertcid_ = 0;
}
inline ::google::protobuf::int32 ListenerToClientsWebRTCRefuse::gamertcid() const {
  // @@protoc_insertion_point(field_get:ListenerToClientsWebRTCRefuse.gameRTCID)
  return gamertcid_;
}
inline void ListenerToClientsWebRTCRefuse::set_gamertcid(::google::protobuf::int32 value) {
  
  gamertcid_ = value;
  // @@protoc_insertion_point(field_set:ListenerToClientsWebRTCRefuse.gameRTCID)
}

// .WebRTCGameRefuseReasons refuseReason = 2;
inline void ListenerToClientsWebRTCRefuse::clear_refusereason() {
  refusereason_ = 0;
}
inline ::WebRTCGameRefuseReasons ListenerToClientsWebRTCRefuse::refusereason() const {
  // @@protoc_insertion_point(field_get:ListenerToClientsWebRTCRefuse.refuseReason)
  return static_cast< ::WebRTCGameRefuseReasons >(refusereason_);
}
inline void ListenerToClientsWebRTCRefuse::set_refusereason(::WebRTCGameRefuseReasons value) {
  
  refusereason_ = value;
  // @@protoc_insertion_point(field_set:ListenerToClientsWebRTCRefuse.refuseReason)
}

// -------------------------------------------------------------------

// ListenerToClientWrappedMessage

// .InvitationToPlayGame invitationToPlay = 1;
inline bool ListenerToClientWrappedMessage::has_invitationtoplay() const {
  return message_case() == kInvitationToPlay;
}
inline void ListenerToClientWrappedMessage::set_has_invitationtoplay() {
  _oneof_case_[0] = kInvitationToPlay;
}
inline void ListenerToClientWrappedMessage::clear_invitationtoplay() {
  if (has_invitationtoplay()) {
    delete message_.invitationtoplay_;
    clear_has_message();
  }
}
inline const ::InvitationToPlayGame& ListenerToClientWrappedMessage::_internal_invitationtoplay() const {
  return *message_.invitationtoplay_;
}
inline ::InvitationToPlayGame* ListenerToClientWrappedMessage::release_invitationtoplay() {
  // @@protoc_insertion_point(field_release:ListenerToClientWrappedMessage.invitationToPlay)
  if (has_invitationtoplay()) {
    clear_has_message();
      ::InvitationToPlayGame* temp = message_.invitationtoplay_;
    message_.invitationtoplay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::InvitationToPlayGame& ListenerToClientWrappedMessage::invitationtoplay() const {
  // @@protoc_insertion_point(field_get:ListenerToClientWrappedMessage.invitationToPlay)
  return has_invitationtoplay()
      ? *message_.invitationtoplay_
      : *reinterpret_cast< ::InvitationToPlayGame*>(&::_InvitationToPlayGame_default_instance_);
}
inline ::InvitationToPlayGame* ListenerToClientWrappedMessage::mutable_invitationtoplay() {
  if (!has_invitationtoplay()) {
    clear_message();
    set_has_invitationtoplay();
    message_.invitationtoplay_ = CreateMaybeMessage< ::InvitationToPlayGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ListenerToClientWrappedMessage.invitationToPlay)
  return message_.invitationtoplay_;
}

// .ListenerToClientGamesStates states = 2;
inline bool ListenerToClientWrappedMessage::has_states() const {
  return message_case() == kStates;
}
inline void ListenerToClientWrappedMessage::set_has_states() {
  _oneof_case_[0] = kStates;
}
inline void ListenerToClientWrappedMessage::clear_states() {
  if (has_states()) {
    delete message_.states_;
    clear_has_message();
  }
}
inline const ::ListenerToClientGamesStates& ListenerToClientWrappedMessage::_internal_states() const {
  return *message_.states_;
}
inline ::ListenerToClientGamesStates* ListenerToClientWrappedMessage::release_states() {
  // @@protoc_insertion_point(field_release:ListenerToClientWrappedMessage.states)
  if (has_states()) {
    clear_has_message();
      ::ListenerToClientGamesStates* temp = message_.states_;
    message_.states_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ListenerToClientGamesStates& ListenerToClientWrappedMessage::states() const {
  // @@protoc_insertion_point(field_get:ListenerToClientWrappedMessage.states)
  return has_states()
      ? *message_.states_
      : *reinterpret_cast< ::ListenerToClientGamesStates*>(&::_ListenerToClientGamesStates_default_instance_);
}
inline ::ListenerToClientGamesStates* ListenerToClientWrappedMessage::mutable_states() {
  if (!has_states()) {
    clear_message();
    set_has_states();
    message_.states_ = CreateMaybeMessage< ::ListenerToClientGamesStates >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ListenerToClientWrappedMessage.states)
  return message_.states_;
}

// .InvitationToViewGame invitationToView = 3;
inline bool ListenerToClientWrappedMessage::has_invitationtoview() const {
  return message_case() == kInvitationToView;
}
inline void ListenerToClientWrappedMessage::set_has_invitationtoview() {
  _oneof_case_[0] = kInvitationToView;
}
inline void ListenerToClientWrappedMessage::clear_invitationtoview() {
  if (has_invitationtoview()) {
    delete message_.invitationtoview_;
    clear_has_message();
  }
}
inline const ::InvitationToViewGame& ListenerToClientWrappedMessage::_internal_invitationtoview() const {
  return *message_.invitationtoview_;
}
inline ::InvitationToViewGame* ListenerToClientWrappedMessage::release_invitationtoview() {
  // @@protoc_insertion_point(field_release:ListenerToClientWrappedMessage.invitationToView)
  if (has_invitationtoview()) {
    clear_has_message();
      ::InvitationToViewGame* temp = message_.invitationtoview_;
    message_.invitationtoview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::InvitationToViewGame& ListenerToClientWrappedMessage::invitationtoview() const {
  // @@protoc_insertion_point(field_get:ListenerToClientWrappedMessage.invitationToView)
  return has_invitationtoview()
      ? *message_.invitationtoview_
      : *reinterpret_cast< ::InvitationToViewGame*>(&::_InvitationToViewGame_default_instance_);
}
inline ::InvitationToViewGame* ListenerToClientWrappedMessage::mutable_invitationtoview() {
  if (!has_invitationtoview()) {
    clear_message();
    set_has_invitationtoview();
    message_.invitationtoview_ = CreateMaybeMessage< ::InvitationToViewGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ListenerToClientWrappedMessage.invitationToView)
  return message_.invitationtoview_;
}

// .ListenerToClientsWebRTCGamesStates rtcStates = 4;
inline bool ListenerToClientWrappedMessage::has_rtcstates() const {
  return message_case() == kRtcStates;
}
inline void ListenerToClientWrappedMessage::set_has_rtcstates() {
  _oneof_case_[0] = kRtcStates;
}
inline void ListenerToClientWrappedMessage::clear_rtcstates() {
  if (has_rtcstates()) {
    delete message_.rtcstates_;
    clear_has_message();
  }
}
inline const ::ListenerToClientsWebRTCGamesStates& ListenerToClientWrappedMessage::_internal_rtcstates() const {
  return *message_.rtcstates_;
}
inline ::ListenerToClientsWebRTCGamesStates* ListenerToClientWrappedMessage::release_rtcstates() {
  // @@protoc_insertion_point(field_release:ListenerToClientWrappedMessage.rtcStates)
  if (has_rtcstates()) {
    clear_has_message();
      ::ListenerToClientsWebRTCGamesStates* temp = message_.rtcstates_;
    message_.rtcstates_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ListenerToClientsWebRTCGamesStates& ListenerToClientWrappedMessage::rtcstates() const {
  // @@protoc_insertion_point(field_get:ListenerToClientWrappedMessage.rtcStates)
  return has_rtcstates()
      ? *message_.rtcstates_
      : *reinterpret_cast< ::ListenerToClientsWebRTCGamesStates*>(&::_ListenerToClientsWebRTCGamesStates_default_instance_);
}
inline ::ListenerToClientsWebRTCGamesStates* ListenerToClientWrappedMessage::mutable_rtcstates() {
  if (!has_rtcstates()) {
    clear_message();
    set_has_rtcstates();
    message_.rtcstates_ = CreateMaybeMessage< ::ListenerToClientsWebRTCGamesStates >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ListenerToClientWrappedMessage.rtcStates)
  return message_.rtcstates_;
}

// .ListenerToClientsWebRTCRefuse rtcRefuse = 5;
inline bool ListenerToClientWrappedMessage::has_rtcrefuse() const {
  return message_case() == kRtcRefuse;
}
inline void ListenerToClientWrappedMessage::set_has_rtcrefuse() {
  _oneof_case_[0] = kRtcRefuse;
}
inline void ListenerToClientWrappedMessage::clear_rtcrefuse() {
  if (has_rtcrefuse()) {
    delete message_.rtcrefuse_;
    clear_has_message();
  }
}
inline const ::ListenerToClientsWebRTCRefuse& ListenerToClientWrappedMessage::_internal_rtcrefuse() const {
  return *message_.rtcrefuse_;
}
inline ::ListenerToClientsWebRTCRefuse* ListenerToClientWrappedMessage::release_rtcrefuse() {
  // @@protoc_insertion_point(field_release:ListenerToClientWrappedMessage.rtcRefuse)
  if (has_rtcrefuse()) {
    clear_has_message();
      ::ListenerToClientsWebRTCRefuse* temp = message_.rtcrefuse_;
    message_.rtcrefuse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ListenerToClientsWebRTCRefuse& ListenerToClientWrappedMessage::rtcrefuse() const {
  // @@protoc_insertion_point(field_get:ListenerToClientWrappedMessage.rtcRefuse)
  return has_rtcrefuse()
      ? *message_.rtcrefuse_
      : *reinterpret_cast< ::ListenerToClientsWebRTCRefuse*>(&::_ListenerToClientsWebRTCRefuse_default_instance_);
}
inline ::ListenerToClientsWebRTCRefuse* ListenerToClientWrappedMessage::mutable_rtcrefuse() {
  if (!has_rtcrefuse()) {
    clear_message();
    set_has_rtcrefuse();
    message_.rtcrefuse_ = CreateMaybeMessage< ::ListenerToClientsWebRTCRefuse >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ListenerToClientWrappedMessage.rtcRefuse)
  return message_.rtcrefuse_;
}

// .RTCAdmin2ClientOffer rtcOffer = 6;
inline bool ListenerToClientWrappedMessage::has_rtcoffer() const {
  return message_case() == kRtcOffer;
}
inline void ListenerToClientWrappedMessage::set_has_rtcoffer() {
  _oneof_case_[0] = kRtcOffer;
}
inline void ListenerToClientWrappedMessage::clear_rtcoffer() {
  if (has_rtcoffer()) {
    delete message_.rtcoffer_;
    clear_has_message();
  }
}
inline const ::RTCAdmin2ClientOffer& ListenerToClientWrappedMessage::_internal_rtcoffer() const {
  return *message_.rtcoffer_;
}
inline ::RTCAdmin2ClientOffer* ListenerToClientWrappedMessage::release_rtcoffer() {
  // @@protoc_insertion_point(field_release:ListenerToClientWrappedMessage.rtcOffer)
  if (has_rtcoffer()) {
    clear_has_message();
      ::RTCAdmin2ClientOffer* temp = message_.rtcoffer_;
    message_.rtcoffer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RTCAdmin2ClientOffer& ListenerToClientWrappedMessage::rtcoffer() const {
  // @@protoc_insertion_point(field_get:ListenerToClientWrappedMessage.rtcOffer)
  return has_rtcoffer()
      ? *message_.rtcoffer_
      : *reinterpret_cast< ::RTCAdmin2ClientOffer*>(&::_RTCAdmin2ClientOffer_default_instance_);
}
inline ::RTCAdmin2ClientOffer* ListenerToClientWrappedMessage::mutable_rtcoffer() {
  if (!has_rtcoffer()) {
    clear_message();
    set_has_rtcoffer();
    message_.rtcoffer_ = CreateMaybeMessage< ::RTCAdmin2ClientOffer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ListenerToClientWrappedMessage.rtcOffer)
  return message_.rtcoffer_;
}

// .RTCClient2AdminAnswer rtcAnswer = 7;
inline bool ListenerToClientWrappedMessage::has_rtcanswer() const {
  return message_case() == kRtcAnswer;
}
inline void ListenerToClientWrappedMessage::set_has_rtcanswer() {
  _oneof_case_[0] = kRtcAnswer;
}
inline void ListenerToClientWrappedMessage::clear_rtcanswer() {
  if (has_rtcanswer()) {
    delete message_.rtcanswer_;
    clear_has_message();
  }
}
inline const ::RTCClient2AdminAnswer& ListenerToClientWrappedMessage::_internal_rtcanswer() const {
  return *message_.rtcanswer_;
}
inline ::RTCClient2AdminAnswer* ListenerToClientWrappedMessage::release_rtcanswer() {
  // @@protoc_insertion_point(field_release:ListenerToClientWrappedMessage.rtcAnswer)
  if (has_rtcanswer()) {
    clear_has_message();
      ::RTCClient2AdminAnswer* temp = message_.rtcanswer_;
    message_.rtcanswer_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::RTCClient2AdminAnswer& ListenerToClientWrappedMessage::rtcanswer() const {
  // @@protoc_insertion_point(field_get:ListenerToClientWrappedMessage.rtcAnswer)
  return has_rtcanswer()
      ? *message_.rtcanswer_
      : *reinterpret_cast< ::RTCClient2AdminAnswer*>(&::_RTCClient2AdminAnswer_default_instance_);
}
inline ::RTCClient2AdminAnswer* ListenerToClientWrappedMessage::mutable_rtcanswer() {
  if (!has_rtcanswer()) {
    clear_message();
    set_has_rtcanswer();
    message_.rtcanswer_ = CreateMaybeMessage< ::RTCClient2AdminAnswer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ListenerToClientWrappedMessage.rtcAnswer)
  return message_.rtcanswer_;
}

inline bool ListenerToClientWrappedMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ListenerToClientWrappedMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ListenerToClientWrappedMessage::MessageCase ListenerToClientWrappedMessage::message_case() const {
  return ListenerToClientWrappedMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ServerWrappedMessage

// .InvitationToPlayGame invitationToPlay = 1;
inline bool ServerWrappedMessage::has_invitationtoplay() const {
  return message_case() == kInvitationToPlay;
}
inline void ServerWrappedMessage::set_has_invitationtoplay() {
  _oneof_case_[0] = kInvitationToPlay;
}
inline void ServerWrappedMessage::clear_invitationtoplay() {
  if (has_invitationtoplay()) {
    delete message_.invitationtoplay_;
    clear_has_message();
  }
}
inline const ::InvitationToPlayGame& ServerWrappedMessage::_internal_invitationtoplay() const {
  return *message_.invitationtoplay_;
}
inline ::InvitationToPlayGame* ServerWrappedMessage::release_invitationtoplay() {
  // @@protoc_insertion_point(field_release:ServerWrappedMessage.invitationToPlay)
  if (has_invitationtoplay()) {
    clear_has_message();
      ::InvitationToPlayGame* temp = message_.invitationtoplay_;
    message_.invitationtoplay_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::InvitationToPlayGame& ServerWrappedMessage::invitationtoplay() const {
  // @@protoc_insertion_point(field_get:ServerWrappedMessage.invitationToPlay)
  return has_invitationtoplay()
      ? *message_.invitationtoplay_
      : *reinterpret_cast< ::InvitationToPlayGame*>(&::_InvitationToPlayGame_default_instance_);
}
inline ::InvitationToPlayGame* ServerWrappedMessage::mutable_invitationtoplay() {
  if (!has_invitationtoplay()) {
    clear_message();
    set_has_invitationtoplay();
    message_.invitationtoplay_ = CreateMaybeMessage< ::InvitationToPlayGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ServerWrappedMessage.invitationToPlay)
  return message_.invitationtoplay_;
}

// .InvitationToViewGame invitationToView = 2;
inline bool ServerWrappedMessage::has_invitationtoview() const {
  return message_case() == kInvitationToView;
}
inline void ServerWrappedMessage::set_has_invitationtoview() {
  _oneof_case_[0] = kInvitationToView;
}
inline void ServerWrappedMessage::clear_invitationtoview() {
  if (has_invitationtoview()) {
    delete message_.invitationtoview_;
    clear_has_message();
  }
}
inline const ::InvitationToViewGame& ServerWrappedMessage::_internal_invitationtoview() const {
  return *message_.invitationtoview_;
}
inline ::InvitationToViewGame* ServerWrappedMessage::release_invitationtoview() {
  // @@protoc_insertion_point(field_release:ServerWrappedMessage.invitationToView)
  if (has_invitationtoview()) {
    clear_has_message();
      ::InvitationToViewGame* temp = message_.invitationtoview_;
    message_.invitationtoview_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::InvitationToViewGame& ServerWrappedMessage::invitationtoview() const {
  // @@protoc_insertion_point(field_get:ServerWrappedMessage.invitationToView)
  return has_invitationtoview()
      ? *message_.invitationtoview_
      : *reinterpret_cast< ::InvitationToViewGame*>(&::_InvitationToViewGame_default_instance_);
}
inline ::InvitationToViewGame* ServerWrappedMessage::mutable_invitationtoview() {
  if (!has_invitationtoview()) {
    clear_message();
    set_has_invitationtoview();
    message_.invitationtoview_ = CreateMaybeMessage< ::InvitationToViewGame >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ServerWrappedMessage.invitationToView)
  return message_.invitationtoview_;
}

inline bool ServerWrappedMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ServerWrappedMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ServerWrappedMessage::MessageCase ServerWrappedMessage::message_case() const {
  return ServerWrappedMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// KeyboardKey

// int32 keyboardKey = 1;
inline void KeyboardKey::clear_keyboardkey() {
  keyboardkey_ = 0;
}
inline ::google::protobuf::int32 KeyboardKey::keyboardkey() const {
  // @@protoc_insertion_point(field_get:KeyboardKey.keyboardKey)
  return keyboardkey_;
}
inline void KeyboardKey::set_keyboardkey(::google::protobuf::int32 value) {
  
  keyboardkey_ = value;
  // @@protoc_insertion_point(field_set:KeyboardKey.keyboardKey)
}

// -------------------------------------------------------------------

// Ping

// int32 ping = 1;
inline void Ping::clear_ping() {
  ping_ = 0;
}
inline ::google::protobuf::int32 Ping::ping() const {
  // @@protoc_insertion_point(field_get:Ping.ping)
  return ping_;
}
inline void Ping::set_ping(::google::protobuf::int32 value) {
  
  ping_ = value;
  // @@protoc_insertion_point(field_set:Ping.ping)
}

// -------------------------------------------------------------------

// SetQulon

// float qulon = 1;
inline void SetQulon::clear_qulon() {
  qulon_ = 0;
}
inline float SetQulon::qulon() const {
  // @@protoc_insertion_point(field_get:SetQulon.qulon)
  return qulon_;
}
inline void SetQulon::set_qulon(float value) {
  
  qulon_ = value;
  // @@protoc_insertion_point(field_set:SetQulon.qulon)
}

// -------------------------------------------------------------------

// SetLightVelocity

// float lightVelocity = 1;
inline void SetLightVelocity::clear_lightvelocity() {
  lightvelocity_ = 0;
}
inline float SetLightVelocity::lightvelocity() const {
  // @@protoc_insertion_point(field_get:SetLightVelocity.lightVelocity)
  return lightvelocity_;
}
inline void SetLightVelocity::set_lightvelocity(float value) {
  
  lightvelocity_ = value;
  // @@protoc_insertion_point(field_set:SetLightVelocity.lightVelocity)
}

// -------------------------------------------------------------------

// SetMagneticCalculated

// bool magneticCalculated = 1;
inline void SetMagneticCalculated::clear_magneticcalculated() {
  magneticcalculated_ = false;
}
inline bool SetMagneticCalculated::magneticcalculated() const {
  // @@protoc_insertion_point(field_get:SetMagneticCalculated.magneticCalculated)
  return magneticcalculated_;
}
inline void SetMagneticCalculated::set_magneticcalculated(bool value) {
  
  magneticcalculated_ = value;
  // @@protoc_insertion_point(field_set:SetMagneticCalculated.magneticCalculated)
}

// -------------------------------------------------------------------

// ClientWrappedMessage

// .KeyboardKey key = 1;
inline bool ClientWrappedMessage::has_key() const {
  return message_case() == kKey;
}
inline void ClientWrappedMessage::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void ClientWrappedMessage::clear_key() {
  if (has_key()) {
    delete message_.key_;
    clear_has_message();
  }
}
inline const ::KeyboardKey& ClientWrappedMessage::_internal_key() const {
  return *message_.key_;
}
inline ::KeyboardKey* ClientWrappedMessage::release_key() {
  // @@protoc_insertion_point(field_release:ClientWrappedMessage.key)
  if (has_key()) {
    clear_has_message();
      ::KeyboardKey* temp = message_.key_;
    message_.key_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::KeyboardKey& ClientWrappedMessage::key() const {
  // @@protoc_insertion_point(field_get:ClientWrappedMessage.key)
  return has_key()
      ? *message_.key_
      : *reinterpret_cast< ::KeyboardKey*>(&::_KeyboardKey_default_instance_);
}
inline ::KeyboardKey* ClientWrappedMessage::mutable_key() {
  if (!has_key()) {
    clear_message();
    set_has_key();
    message_.key_ = CreateMaybeMessage< ::KeyboardKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientWrappedMessage.key)
  return message_.key_;
}

// .Ping ping = 2;
inline bool ClientWrappedMessage::has_ping() const {
  return message_case() == kPing;
}
inline void ClientWrappedMessage::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void ClientWrappedMessage::clear_ping() {
  if (has_ping()) {
    delete message_.ping_;
    clear_has_message();
  }
}
inline const ::Ping& ClientWrappedMessage::_internal_ping() const {
  return *message_.ping_;
}
inline ::Ping* ClientWrappedMessage::release_ping() {
  // @@protoc_insertion_point(field_release:ClientWrappedMessage.ping)
  if (has_ping()) {
    clear_has_message();
      ::Ping* temp = message_.ping_;
    message_.ping_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Ping& ClientWrappedMessage::ping() const {
  // @@protoc_insertion_point(field_get:ClientWrappedMessage.ping)
  return has_ping()
      ? *message_.ping_
      : *reinterpret_cast< ::Ping*>(&::_Ping_default_instance_);
}
inline ::Ping* ClientWrappedMessage::mutable_ping() {
  if (!has_ping()) {
    clear_message();
    set_has_ping();
    message_.ping_ = CreateMaybeMessage< ::Ping >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientWrappedMessage.ping)
  return message_.ping_;
}

// .SetQulon qulon = 3;
inline bool ClientWrappedMessage::has_qulon() const {
  return message_case() == kQulon;
}
inline void ClientWrappedMessage::set_has_qulon() {
  _oneof_case_[0] = kQulon;
}
inline void ClientWrappedMessage::clear_qulon() {
  if (has_qulon()) {
    delete message_.qulon_;
    clear_has_message();
  }
}
inline const ::SetQulon& ClientWrappedMessage::_internal_qulon() const {
  return *message_.qulon_;
}
inline ::SetQulon* ClientWrappedMessage::release_qulon() {
  // @@protoc_insertion_point(field_release:ClientWrappedMessage.qulon)
  if (has_qulon()) {
    clear_has_message();
      ::SetQulon* temp = message_.qulon_;
    message_.qulon_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SetQulon& ClientWrappedMessage::qulon() const {
  // @@protoc_insertion_point(field_get:ClientWrappedMessage.qulon)
  return has_qulon()
      ? *message_.qulon_
      : *reinterpret_cast< ::SetQulon*>(&::_SetQulon_default_instance_);
}
inline ::SetQulon* ClientWrappedMessage::mutable_qulon() {
  if (!has_qulon()) {
    clear_message();
    set_has_qulon();
    message_.qulon_ = CreateMaybeMessage< ::SetQulon >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientWrappedMessage.qulon)
  return message_.qulon_;
}

// .SetLightVelocity lightVelocity = 4;
inline bool ClientWrappedMessage::has_lightvelocity() const {
  return message_case() == kLightVelocity;
}
inline void ClientWrappedMessage::set_has_lightvelocity() {
  _oneof_case_[0] = kLightVelocity;
}
inline void ClientWrappedMessage::clear_lightvelocity() {
  if (has_lightvelocity()) {
    delete message_.lightvelocity_;
    clear_has_message();
  }
}
inline const ::SetLightVelocity& ClientWrappedMessage::_internal_lightvelocity() const {
  return *message_.lightvelocity_;
}
inline ::SetLightVelocity* ClientWrappedMessage::release_lightvelocity() {
  // @@protoc_insertion_point(field_release:ClientWrappedMessage.lightVelocity)
  if (has_lightvelocity()) {
    clear_has_message();
      ::SetLightVelocity* temp = message_.lightvelocity_;
    message_.lightvelocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SetLightVelocity& ClientWrappedMessage::lightvelocity() const {
  // @@protoc_insertion_point(field_get:ClientWrappedMessage.lightVelocity)
  return has_lightvelocity()
      ? *message_.lightvelocity_
      : *reinterpret_cast< ::SetLightVelocity*>(&::_SetLightVelocity_default_instance_);
}
inline ::SetLightVelocity* ClientWrappedMessage::mutable_lightvelocity() {
  if (!has_lightvelocity()) {
    clear_message();
    set_has_lightvelocity();
    message_.lightvelocity_ = CreateMaybeMessage< ::SetLightVelocity >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientWrappedMessage.lightVelocity)
  return message_.lightvelocity_;
}

// .SetMagneticCalculated magneticCalculated = 5;
inline bool ClientWrappedMessage::has_magneticcalculated() const {
  return message_case() == kMagneticCalculated;
}
inline void ClientWrappedMessage::set_has_magneticcalculated() {
  _oneof_case_[0] = kMagneticCalculated;
}
inline void ClientWrappedMessage::clear_magneticcalculated() {
  if (has_magneticcalculated()) {
    delete message_.magneticcalculated_;
    clear_has_message();
  }
}
inline const ::SetMagneticCalculated& ClientWrappedMessage::_internal_magneticcalculated() const {
  return *message_.magneticcalculated_;
}
inline ::SetMagneticCalculated* ClientWrappedMessage::release_magneticcalculated() {
  // @@protoc_insertion_point(field_release:ClientWrappedMessage.magneticCalculated)
  if (has_magneticcalculated()) {
    clear_has_message();
      ::SetMagneticCalculated* temp = message_.magneticcalculated_;
    message_.magneticcalculated_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SetMagneticCalculated& ClientWrappedMessage::magneticcalculated() const {
  // @@protoc_insertion_point(field_get:ClientWrappedMessage.magneticCalculated)
  return has_magneticcalculated()
      ? *message_.magneticcalculated_
      : *reinterpret_cast< ::SetMagneticCalculated*>(&::_SetMagneticCalculated_default_instance_);
}
inline ::SetMagneticCalculated* ClientWrappedMessage::mutable_magneticcalculated() {
  if (!has_magneticcalculated()) {
    clear_message();
    set_has_magneticcalculated();
    message_.magneticcalculated_ = CreateMaybeMessage< ::SetMagneticCalculated >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:ClientWrappedMessage.magneticCalculated)
  return message_.magneticcalculated_;
}

inline bool ClientWrappedMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void ClientWrappedMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline ClientWrappedMessage::MessageCase ClientWrappedMessage::message_case() const {
  return ClientWrappedMessage::MessageCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RoomInfo_GameStatusEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RoomInfo_GameStatusEnum>() {
  return ::RoomInfo_GameStatusEnum_descriptor();
}
template <> struct is_proto_enum< ::OneChargeInfo_Charge2DType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OneChargeInfo_Charge2DType>() {
  return ::OneChargeInfo_Charge2DType_descriptor();
}
template <> struct is_proto_enum< ::ShowPaletteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ShowPaletteType>() {
  return ::ShowPaletteType_descriptor();
}
template <> struct is_proto_enum< ::WebRTCPlayerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WebRTCPlayerStatus>() {
  return ::WebRTCPlayerStatus_descriptor();
}
template <> struct is_proto_enum< ::WebRTCGameRefuseReasons> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::WebRTCGameRefuseReasons>() {
  return ::WebRTCGameRefuseReasons_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_client_5flistener_2eproto
